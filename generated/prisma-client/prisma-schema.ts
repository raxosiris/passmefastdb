// Code generated by Prisma (prisma@1.31.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Agent {
  id: ID!
  zenId: Int
  name: String!
  email: String
  booking(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
}

type AgentConnection {
  pageInfo: PageInfo!
  edges: [AgentEdge]!
  aggregate: AggregateAgent!
}

input AgentCreateInput {
  zenId: Int
  name: String!
  email: String
  booking: BookingCreateManyWithoutAgentInput
}

input AgentCreateOneInput {
  create: AgentCreateInput
  connect: AgentWhereUniqueInput
}

input AgentCreateOneWithoutBookingInput {
  create: AgentCreateWithoutBookingInput
  connect: AgentWhereUniqueInput
}

input AgentCreateWithoutBookingInput {
  zenId: Int
  name: String!
  email: String
}

type AgentEdge {
  node: Agent!
  cursor: String!
}

enum AgentOrderByInput {
  id_ASC
  id_DESC
  zenId_ASC
  zenId_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
}

type AgentPreviousValues {
  id: ID!
  zenId: Int
  name: String!
  email: String
}

type AgentSubscriptionPayload {
  mutation: MutationType!
  node: Agent
  updatedFields: [String!]
  previousValues: AgentPreviousValues
}

input AgentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AgentWhereInput
  AND: [AgentSubscriptionWhereInput!]
  OR: [AgentSubscriptionWhereInput!]
  NOT: [AgentSubscriptionWhereInput!]
}

input AgentUpdateDataInput {
  zenId: Int
  name: String
  email: String
  booking: BookingUpdateManyWithoutAgentInput
}

input AgentUpdateInput {
  zenId: Int
  name: String
  email: String
  booking: BookingUpdateManyWithoutAgentInput
}

input AgentUpdateManyMutationInput {
  zenId: Int
  name: String
  email: String
}

input AgentUpdateOneInput {
  create: AgentCreateInput
  update: AgentUpdateDataInput
  upsert: AgentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AgentWhereUniqueInput
}

input AgentUpdateOneRequiredWithoutBookingInput {
  create: AgentCreateWithoutBookingInput
  update: AgentUpdateWithoutBookingDataInput
  upsert: AgentUpsertWithoutBookingInput
  connect: AgentWhereUniqueInput
}

input AgentUpdateWithoutBookingDataInput {
  zenId: Int
  name: String
  email: String
}

input AgentUpsertNestedInput {
  update: AgentUpdateDataInput!
  create: AgentCreateInput!
}

input AgentUpsertWithoutBookingInput {
  update: AgentUpdateWithoutBookingDataInput!
  create: AgentCreateWithoutBookingInput!
}

input AgentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  zenId: Int
  zenId_not: Int
  zenId_in: [Int!]
  zenId_not_in: [Int!]
  zenId_lt: Int
  zenId_lte: Int
  zenId_gt: Int
  zenId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  booking_every: BookingWhereInput
  booking_some: BookingWhereInput
  booking_none: BookingWhereInput
  AND: [AgentWhereInput!]
  OR: [AgentWhereInput!]
  NOT: [AgentWhereInput!]
}

input AgentWhereUniqueInput {
  id: ID
  zenId: Int
  email: String
}

type AggregateAgent {
  count: Int!
}

type AggregateBooking {
  count: Int!
}

type AggregateDebt {
  count: Int!
}

type AggregateDebtChase {
  count: Int!
}

type AggregateFastTrackTest {
  count: Int!
}

type AggregateInstructor {
  count: Int!
}

type AggregateLatestHistoryId {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePracticalTest {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Booking {
  id: ID!
  zenId: Int
  name: String!
  bookedAt: DateTime
  debt: Debt
  agent: Agent!
  student: Student
  amount: Float!
  instructor(where: InstructorWhereInput, orderBy: InstructorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Instructor!]
}

type BookingConnection {
  pageInfo: PageInfo!
  edges: [BookingEdge]!
  aggregate: AggregateBooking!
}

input BookingCreateInput {
  zenId: Int
  name: String!
  bookedAt: DateTime
  debt: DebtCreateOneWithoutBookingInput
  agent: AgentCreateOneWithoutBookingInput!
  student: StudentCreateOneWithoutBookingsInput
  amount: Float!
  instructor: InstructorCreateManyWithoutBookingsInput
}

input BookingCreateManyWithoutAgentInput {
  create: [BookingCreateWithoutAgentInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateManyWithoutInstructorInput {
  create: [BookingCreateWithoutInstructorInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateManyWithoutStudentInput {
  create: [BookingCreateWithoutStudentInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateOneInput {
  create: BookingCreateInput
  connect: BookingWhereUniqueInput
}

input BookingCreateOneWithoutDebtInput {
  create: BookingCreateWithoutDebtInput
  connect: BookingWhereUniqueInput
}

input BookingCreateWithoutAgentInput {
  zenId: Int
  name: String!
  bookedAt: DateTime
  debt: DebtCreateOneWithoutBookingInput
  student: StudentCreateOneWithoutBookingsInput
  amount: Float!
  instructor: InstructorCreateManyWithoutBookingsInput
}

input BookingCreateWithoutDebtInput {
  zenId: Int
  name: String!
  bookedAt: DateTime
  agent: AgentCreateOneWithoutBookingInput!
  student: StudentCreateOneWithoutBookingsInput
  amount: Float!
  instructor: InstructorCreateManyWithoutBookingsInput
}

input BookingCreateWithoutInstructorInput {
  zenId: Int
  name: String!
  bookedAt: DateTime
  debt: DebtCreateOneWithoutBookingInput
  agent: AgentCreateOneWithoutBookingInput!
  student: StudentCreateOneWithoutBookingsInput
  amount: Float!
}

input BookingCreateWithoutStudentInput {
  zenId: Int
  name: String!
  bookedAt: DateTime
  debt: DebtCreateOneWithoutBookingInput
  agent: AgentCreateOneWithoutBookingInput!
  amount: Float!
  instructor: InstructorCreateManyWithoutBookingsInput
}

type BookingEdge {
  node: Booking!
  cursor: String!
}

enum BookingOrderByInput {
  id_ASC
  id_DESC
  zenId_ASC
  zenId_DESC
  name_ASC
  name_DESC
  bookedAt_ASC
  bookedAt_DESC
  amount_ASC
  amount_DESC
}

type BookingPreviousValues {
  id: ID!
  zenId: Int
  name: String!
  bookedAt: DateTime
  amount: Float!
}

input BookingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  zenId: Int
  zenId_not: Int
  zenId_in: [Int!]
  zenId_not_in: [Int!]
  zenId_lt: Int
  zenId_lte: Int
  zenId_gt: Int
  zenId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bookedAt: DateTime
  bookedAt_not: DateTime
  bookedAt_in: [DateTime!]
  bookedAt_not_in: [DateTime!]
  bookedAt_lt: DateTime
  bookedAt_lte: DateTime
  bookedAt_gt: DateTime
  bookedAt_gte: DateTime
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [BookingScalarWhereInput!]
  OR: [BookingScalarWhereInput!]
  NOT: [BookingScalarWhereInput!]
}

type BookingSubscriptionPayload {
  mutation: MutationType!
  node: Booking
  updatedFields: [String!]
  previousValues: BookingPreviousValues
}

input BookingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookingWhereInput
  AND: [BookingSubscriptionWhereInput!]
  OR: [BookingSubscriptionWhereInput!]
  NOT: [BookingSubscriptionWhereInput!]
}

input BookingUpdateDataInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  debt: DebtUpdateOneWithoutBookingInput
  agent: AgentUpdateOneRequiredWithoutBookingInput
  student: StudentUpdateOneWithoutBookingsInput
  amount: Float
  instructor: InstructorUpdateManyWithoutBookingsInput
}

input BookingUpdateInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  debt: DebtUpdateOneWithoutBookingInput
  agent: AgentUpdateOneRequiredWithoutBookingInput
  student: StudentUpdateOneWithoutBookingsInput
  amount: Float
  instructor: InstructorUpdateManyWithoutBookingsInput
}

input BookingUpdateManyDataInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  amount: Float
}

input BookingUpdateManyMutationInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  amount: Float
}

input BookingUpdateManyWithoutAgentInput {
  create: [BookingCreateWithoutAgentInput!]
  delete: [BookingWhereUniqueInput!]
  connect: [BookingWhereUniqueInput!]
  set: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutAgentInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutAgentInput!]
  deleteMany: [BookingScalarWhereInput!]
  updateMany: [BookingUpdateManyWithWhereNestedInput!]
}

input BookingUpdateManyWithoutInstructorInput {
  create: [BookingCreateWithoutInstructorInput!]
  delete: [BookingWhereUniqueInput!]
  connect: [BookingWhereUniqueInput!]
  set: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutInstructorInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutInstructorInput!]
  deleteMany: [BookingScalarWhereInput!]
  updateMany: [BookingUpdateManyWithWhereNestedInput!]
}

input BookingUpdateManyWithoutStudentInput {
  create: [BookingCreateWithoutStudentInput!]
  delete: [BookingWhereUniqueInput!]
  connect: [BookingWhereUniqueInput!]
  set: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [BookingScalarWhereInput!]
  updateMany: [BookingUpdateManyWithWhereNestedInput!]
}

input BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput!
  data: BookingUpdateManyDataInput!
}

input BookingUpdateOneInput {
  create: BookingCreateInput
  update: BookingUpdateDataInput
  upsert: BookingUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BookingWhereUniqueInput
}

input BookingUpdateOneWithoutDebtInput {
  create: BookingCreateWithoutDebtInput
  update: BookingUpdateWithoutDebtDataInput
  upsert: BookingUpsertWithoutDebtInput
  delete: Boolean
  disconnect: Boolean
  connect: BookingWhereUniqueInput
}

input BookingUpdateWithoutAgentDataInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  debt: DebtUpdateOneWithoutBookingInput
  student: StudentUpdateOneWithoutBookingsInput
  amount: Float
  instructor: InstructorUpdateManyWithoutBookingsInput
}

input BookingUpdateWithoutDebtDataInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  agent: AgentUpdateOneRequiredWithoutBookingInput
  student: StudentUpdateOneWithoutBookingsInput
  amount: Float
  instructor: InstructorUpdateManyWithoutBookingsInput
}

input BookingUpdateWithoutInstructorDataInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  debt: DebtUpdateOneWithoutBookingInput
  agent: AgentUpdateOneRequiredWithoutBookingInput
  student: StudentUpdateOneWithoutBookingsInput
  amount: Float
}

input BookingUpdateWithoutStudentDataInput {
  zenId: Int
  name: String
  bookedAt: DateTime
  debt: DebtUpdateOneWithoutBookingInput
  agent: AgentUpdateOneRequiredWithoutBookingInput
  amount: Float
  instructor: InstructorUpdateManyWithoutBookingsInput
}

input BookingUpdateWithWhereUniqueWithoutAgentInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutAgentDataInput!
}

input BookingUpdateWithWhereUniqueWithoutInstructorInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutInstructorDataInput!
}

input BookingUpdateWithWhereUniqueWithoutStudentInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutStudentDataInput!
}

input BookingUpsertNestedInput {
  update: BookingUpdateDataInput!
  create: BookingCreateInput!
}

input BookingUpsertWithoutDebtInput {
  update: BookingUpdateWithoutDebtDataInput!
  create: BookingCreateWithoutDebtInput!
}

input BookingUpsertWithWhereUniqueWithoutAgentInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutAgentDataInput!
  create: BookingCreateWithoutAgentInput!
}

input BookingUpsertWithWhereUniqueWithoutInstructorInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutInstructorDataInput!
  create: BookingCreateWithoutInstructorInput!
}

input BookingUpsertWithWhereUniqueWithoutStudentInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutStudentDataInput!
  create: BookingCreateWithoutStudentInput!
}

input BookingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  zenId: Int
  zenId_not: Int
  zenId_in: [Int!]
  zenId_not_in: [Int!]
  zenId_lt: Int
  zenId_lte: Int
  zenId_gt: Int
  zenId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bookedAt: DateTime
  bookedAt_not: DateTime
  bookedAt_in: [DateTime!]
  bookedAt_not_in: [DateTime!]
  bookedAt_lt: DateTime
  bookedAt_lte: DateTime
  bookedAt_gt: DateTime
  bookedAt_gte: DateTime
  debt: DebtWhereInput
  agent: AgentWhereInput
  student: StudentWhereInput
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  instructor_every: InstructorWhereInput
  instructor_some: InstructorWhereInput
  instructor_none: InstructorWhereInput
  AND: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  NOT: [BookingWhereInput!]
}

input BookingWhereUniqueInput {
  id: ID
  zenId: Int
}

scalar DateTime

type Debt {
  id: ID!
  booking: Booking
  agent: Agent
  instructor: Instructor!
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases(where: DebtChaseWhereInput, orderBy: DebtChaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DebtChase!]
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
}

type DebtChase {
  id: ID!
  debt: Debt!
  notes: String
  chasedOn: DateTime!
  chasedBy: Agent
}

type DebtChaseConnection {
  pageInfo: PageInfo!
  edges: [DebtChaseEdge]!
  aggregate: AggregateDebtChase!
}

input DebtChaseCreateInput {
  debt: DebtCreateOneWithoutChasesInput!
  notes: String
  chasedOn: DateTime!
  chasedBy: AgentCreateOneInput
}

input DebtChaseCreateManyWithoutDebtInput {
  create: [DebtChaseCreateWithoutDebtInput!]
  connect: [DebtChaseWhereUniqueInput!]
}

input DebtChaseCreateWithoutDebtInput {
  notes: String
  chasedOn: DateTime!
  chasedBy: AgentCreateOneInput
}

type DebtChaseEdge {
  node: DebtChase!
  cursor: String!
}

enum DebtChaseOrderByInput {
  id_ASC
  id_DESC
  notes_ASC
  notes_DESC
  chasedOn_ASC
  chasedOn_DESC
}

type DebtChasePreviousValues {
  id: ID!
  notes: String
  chasedOn: DateTime!
}

input DebtChaseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  chasedOn: DateTime
  chasedOn_not: DateTime
  chasedOn_in: [DateTime!]
  chasedOn_not_in: [DateTime!]
  chasedOn_lt: DateTime
  chasedOn_lte: DateTime
  chasedOn_gt: DateTime
  chasedOn_gte: DateTime
  AND: [DebtChaseScalarWhereInput!]
  OR: [DebtChaseScalarWhereInput!]
  NOT: [DebtChaseScalarWhereInput!]
}

type DebtChaseSubscriptionPayload {
  mutation: MutationType!
  node: DebtChase
  updatedFields: [String!]
  previousValues: DebtChasePreviousValues
}

input DebtChaseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DebtChaseWhereInput
  AND: [DebtChaseSubscriptionWhereInput!]
  OR: [DebtChaseSubscriptionWhereInput!]
  NOT: [DebtChaseSubscriptionWhereInput!]
}

input DebtChaseUpdateInput {
  debt: DebtUpdateOneRequiredWithoutChasesInput
  notes: String
  chasedOn: DateTime
  chasedBy: AgentUpdateOneInput
}

input DebtChaseUpdateManyDataInput {
  notes: String
  chasedOn: DateTime
}

input DebtChaseUpdateManyMutationInput {
  notes: String
  chasedOn: DateTime
}

input DebtChaseUpdateManyWithoutDebtInput {
  create: [DebtChaseCreateWithoutDebtInput!]
  delete: [DebtChaseWhereUniqueInput!]
  connect: [DebtChaseWhereUniqueInput!]
  set: [DebtChaseWhereUniqueInput!]
  disconnect: [DebtChaseWhereUniqueInput!]
  update: [DebtChaseUpdateWithWhereUniqueWithoutDebtInput!]
  upsert: [DebtChaseUpsertWithWhereUniqueWithoutDebtInput!]
  deleteMany: [DebtChaseScalarWhereInput!]
  updateMany: [DebtChaseUpdateManyWithWhereNestedInput!]
}

input DebtChaseUpdateManyWithWhereNestedInput {
  where: DebtChaseScalarWhereInput!
  data: DebtChaseUpdateManyDataInput!
}

input DebtChaseUpdateWithoutDebtDataInput {
  notes: String
  chasedOn: DateTime
  chasedBy: AgentUpdateOneInput
}

input DebtChaseUpdateWithWhereUniqueWithoutDebtInput {
  where: DebtChaseWhereUniqueInput!
  data: DebtChaseUpdateWithoutDebtDataInput!
}

input DebtChaseUpsertWithWhereUniqueWithoutDebtInput {
  where: DebtChaseWhereUniqueInput!
  update: DebtChaseUpdateWithoutDebtDataInput!
  create: DebtChaseCreateWithoutDebtInput!
}

input DebtChaseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  debt: DebtWhereInput
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  chasedOn: DateTime
  chasedOn_not: DateTime
  chasedOn_in: [DateTime!]
  chasedOn_not_in: [DateTime!]
  chasedOn_lt: DateTime
  chasedOn_lte: DateTime
  chasedOn_gt: DateTime
  chasedOn_gte: DateTime
  chasedBy: AgentWhereInput
  AND: [DebtChaseWhereInput!]
  OR: [DebtChaseWhereInput!]
  NOT: [DebtChaseWhereInput!]
}

input DebtChaseWhereUniqueInput {
  id: ID
}

type DebtConnection {
  pageInfo: PageInfo!
  edges: [DebtEdge]!
  aggregate: AggregateDebt!
}

input DebtCreateInput {
  booking: BookingCreateOneWithoutDebtInput
  agent: AgentCreateOneInput
  instructor: InstructorCreateOneWithoutDebtInput!
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseCreateManyWithoutDebtInput
  payments: PaymentCreateManyWithoutDebtInput
}

input DebtCreateManyWithoutInstructorInput {
  create: [DebtCreateWithoutInstructorInput!]
  connect: [DebtWhereUniqueInput!]
}

input DebtCreateOneWithoutBookingInput {
  create: DebtCreateWithoutBookingInput
  connect: DebtWhereUniqueInput
}

input DebtCreateOneWithoutChasesInput {
  create: DebtCreateWithoutChasesInput
  connect: DebtWhereUniqueInput
}

input DebtCreateOneWithoutPaymentsInput {
  create: DebtCreateWithoutPaymentsInput
  connect: DebtWhereUniqueInput
}

input DebtCreateWithoutBookingInput {
  agent: AgentCreateOneInput
  instructor: InstructorCreateOneWithoutDebtInput!
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseCreateManyWithoutDebtInput
  payments: PaymentCreateManyWithoutDebtInput
}

input DebtCreateWithoutChasesInput {
  booking: BookingCreateOneWithoutDebtInput
  agent: AgentCreateOneInput
  instructor: InstructorCreateOneWithoutDebtInput!
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  payments: PaymentCreateManyWithoutDebtInput
}

input DebtCreateWithoutInstructorInput {
  booking: BookingCreateOneWithoutDebtInput
  agent: AgentCreateOneInput
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseCreateManyWithoutDebtInput
  payments: PaymentCreateManyWithoutDebtInput
}

input DebtCreateWithoutPaymentsInput {
  booking: BookingCreateOneWithoutDebtInput
  agent: AgentCreateOneInput
  instructor: InstructorCreateOneWithoutDebtInput!
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseCreateManyWithoutDebtInput
}

type DebtEdge {
  node: Debt!
  cursor: String!
}

enum DebtOrderByInput {
  id_ASC
  id_DESC
  initialAmount_ASC
  initialAmount_DESC
  currentAmount_ASC
  currentAmount_DESC
  paidOff_ASC
  paidOff_DESC
  status_ASC
  status_DESC
  dueSince_ASC
  dueSince_DESC
  notes_ASC
  notes_DESC
}

type DebtPreviousValues {
  id: ID!
  initialAmount: Float!
  currentAmount: Float!
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
}

input DebtScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  initialAmount: Float
  initialAmount_not: Float
  initialAmount_in: [Float!]
  initialAmount_not_in: [Float!]
  initialAmount_lt: Float
  initialAmount_lte: Float
  initialAmount_gt: Float
  initialAmount_gte: Float
  currentAmount: Float
  currentAmount_not: Float
  currentAmount_in: [Float!]
  currentAmount_not_in: [Float!]
  currentAmount_lt: Float
  currentAmount_lte: Float
  currentAmount_gt: Float
  currentAmount_gte: Float
  paidOff: Boolean
  paidOff_not: Boolean
  status: DebtStatus
  status_not: DebtStatus
  status_in: [DebtStatus!]
  status_not_in: [DebtStatus!]
  dueSince: DateTime
  dueSince_not: DateTime
  dueSince_in: [DateTime!]
  dueSince_not_in: [DateTime!]
  dueSince_lt: DateTime
  dueSince_lte: DateTime
  dueSince_gt: DateTime
  dueSince_gte: DateTime
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [DebtScalarWhereInput!]
  OR: [DebtScalarWhereInput!]
  NOT: [DebtScalarWhereInput!]
}

enum DebtStatus {
  NEEDSCHASING
  CHASED
  PAYMENTAGREED
  BADDEBT
  FULLYPAID
}

type DebtSubscriptionPayload {
  mutation: MutationType!
  node: Debt
  updatedFields: [String!]
  previousValues: DebtPreviousValues
}

input DebtSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DebtWhereInput
  AND: [DebtSubscriptionWhereInput!]
  OR: [DebtSubscriptionWhereInput!]
  NOT: [DebtSubscriptionWhereInput!]
}

input DebtUpdateInput {
  booking: BookingUpdateOneWithoutDebtInput
  agent: AgentUpdateOneInput
  instructor: InstructorUpdateOneRequiredWithoutDebtInput
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseUpdateManyWithoutDebtInput
  payments: PaymentUpdateManyWithoutDebtInput
}

input DebtUpdateManyDataInput {
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
}

input DebtUpdateManyMutationInput {
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
}

input DebtUpdateManyWithoutInstructorInput {
  create: [DebtCreateWithoutInstructorInput!]
  delete: [DebtWhereUniqueInput!]
  connect: [DebtWhereUniqueInput!]
  set: [DebtWhereUniqueInput!]
  disconnect: [DebtWhereUniqueInput!]
  update: [DebtUpdateWithWhereUniqueWithoutInstructorInput!]
  upsert: [DebtUpsertWithWhereUniqueWithoutInstructorInput!]
  deleteMany: [DebtScalarWhereInput!]
  updateMany: [DebtUpdateManyWithWhereNestedInput!]
}

input DebtUpdateManyWithWhereNestedInput {
  where: DebtScalarWhereInput!
  data: DebtUpdateManyDataInput!
}

input DebtUpdateOneRequiredWithoutChasesInput {
  create: DebtCreateWithoutChasesInput
  update: DebtUpdateWithoutChasesDataInput
  upsert: DebtUpsertWithoutChasesInput
  connect: DebtWhereUniqueInput
}

input DebtUpdateOneRequiredWithoutPaymentsInput {
  create: DebtCreateWithoutPaymentsInput
  update: DebtUpdateWithoutPaymentsDataInput
  upsert: DebtUpsertWithoutPaymentsInput
  connect: DebtWhereUniqueInput
}

input DebtUpdateOneWithoutBookingInput {
  create: DebtCreateWithoutBookingInput
  update: DebtUpdateWithoutBookingDataInput
  upsert: DebtUpsertWithoutBookingInput
  delete: Boolean
  disconnect: Boolean
  connect: DebtWhereUniqueInput
}

input DebtUpdateWithoutBookingDataInput {
  agent: AgentUpdateOneInput
  instructor: InstructorUpdateOneRequiredWithoutDebtInput
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseUpdateManyWithoutDebtInput
  payments: PaymentUpdateManyWithoutDebtInput
}

input DebtUpdateWithoutChasesDataInput {
  booking: BookingUpdateOneWithoutDebtInput
  agent: AgentUpdateOneInput
  instructor: InstructorUpdateOneRequiredWithoutDebtInput
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  payments: PaymentUpdateManyWithoutDebtInput
}

input DebtUpdateWithoutInstructorDataInput {
  booking: BookingUpdateOneWithoutDebtInput
  agent: AgentUpdateOneInput
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseUpdateManyWithoutDebtInput
  payments: PaymentUpdateManyWithoutDebtInput
}

input DebtUpdateWithoutPaymentsDataInput {
  booking: BookingUpdateOneWithoutDebtInput
  agent: AgentUpdateOneInput
  instructor: InstructorUpdateOneRequiredWithoutDebtInput
  initialAmount: Float
  currentAmount: Float
  paidOff: Boolean
  status: DebtStatus
  dueSince: DateTime
  notes: String
  chases: DebtChaseUpdateManyWithoutDebtInput
}

input DebtUpdateWithWhereUniqueWithoutInstructorInput {
  where: DebtWhereUniqueInput!
  data: DebtUpdateWithoutInstructorDataInput!
}

input DebtUpsertWithoutBookingInput {
  update: DebtUpdateWithoutBookingDataInput!
  create: DebtCreateWithoutBookingInput!
}

input DebtUpsertWithoutChasesInput {
  update: DebtUpdateWithoutChasesDataInput!
  create: DebtCreateWithoutChasesInput!
}

input DebtUpsertWithoutPaymentsInput {
  update: DebtUpdateWithoutPaymentsDataInput!
  create: DebtCreateWithoutPaymentsInput!
}

input DebtUpsertWithWhereUniqueWithoutInstructorInput {
  where: DebtWhereUniqueInput!
  update: DebtUpdateWithoutInstructorDataInput!
  create: DebtCreateWithoutInstructorInput!
}

input DebtWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  booking: BookingWhereInput
  agent: AgentWhereInput
  instructor: InstructorWhereInput
  initialAmount: Float
  initialAmount_not: Float
  initialAmount_in: [Float!]
  initialAmount_not_in: [Float!]
  initialAmount_lt: Float
  initialAmount_lte: Float
  initialAmount_gt: Float
  initialAmount_gte: Float
  currentAmount: Float
  currentAmount_not: Float
  currentAmount_in: [Float!]
  currentAmount_not_in: [Float!]
  currentAmount_lt: Float
  currentAmount_lte: Float
  currentAmount_gt: Float
  currentAmount_gte: Float
  paidOff: Boolean
  paidOff_not: Boolean
  status: DebtStatus
  status_not: DebtStatus
  status_in: [DebtStatus!]
  status_not_in: [DebtStatus!]
  dueSince: DateTime
  dueSince_not: DateTime
  dueSince_in: [DateTime!]
  dueSince_not_in: [DateTime!]
  dueSince_lt: DateTime
  dueSince_lte: DateTime
  dueSince_gt: DateTime
  dueSince_gte: DateTime
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  chases_every: DebtChaseWhereInput
  chases_some: DebtChaseWhereInput
  chases_none: DebtChaseWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  AND: [DebtWhereInput!]
  OR: [DebtWhereInput!]
  NOT: [DebtWhereInput!]
}

input DebtWhereUniqueInput {
  id: ID
}

type FastTrackTest {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  studentName: String
  area: String
  dealOwner: String
  instructor: String
  testCentrePrimary: String
  testCentreSecondary: String
  drivinglicense: String!
  applicationRef: String!
  studentPostcode: String
  searchPostcode: String
  startDate: String
  endDate: String
  hoursToAvoid: [Int!]!
  daysToAvoid: [Int!]!
  datesToAvoid: [Int!]!
  testCentres: [Int!]!
  specificDays: [Int!]!
  specificDates: [Int!]!
  specificHours: [Int!]!
  booked: Boolean
  bookedDate: DateTime
  bookedCentre: Int
  timeWhenBooked: DateTime
  minimumDelay: Int
  postcode: String
  stopLooking: Boolean
}

type FastTrackTestConnection {
  pageInfo: PageInfo!
  edges: [FastTrackTestEdge]!
  aggregate: AggregateFastTrackTest!
}

input FastTrackTestCreatedatesToAvoidInput {
  set: [Int!]
}

input FastTrackTestCreatedaysToAvoidInput {
  set: [Int!]
}

input FastTrackTestCreatehoursToAvoidInput {
  set: [Int!]
}

input FastTrackTestCreateInput {
  studentName: String
  area: String
  dealOwner: String
  instructor: String
  testCentrePrimary: String
  testCentreSecondary: String
  drivinglicense: String!
  applicationRef: String!
  studentPostcode: String
  searchPostcode: String
  startDate: String
  endDate: String
  hoursToAvoid: FastTrackTestCreatehoursToAvoidInput
  daysToAvoid: FastTrackTestCreatedaysToAvoidInput
  datesToAvoid: FastTrackTestCreatedatesToAvoidInput
  testCentres: FastTrackTestCreatetestCentresInput
  specificDays: FastTrackTestCreatespecificDaysInput
  specificDates: FastTrackTestCreatespecificDatesInput
  specificHours: FastTrackTestCreatespecificHoursInput
  booked: Boolean
  bookedDate: DateTime
  bookedCentre: Int
  timeWhenBooked: DateTime
  minimumDelay: Int
  postcode: String
  stopLooking: Boolean
}

input FastTrackTestCreatespecificDatesInput {
  set: [Int!]
}

input FastTrackTestCreatespecificDaysInput {
  set: [Int!]
}

input FastTrackTestCreatespecificHoursInput {
  set: [Int!]
}

input FastTrackTestCreatetestCentresInput {
  set: [Int!]
}

type FastTrackTestEdge {
  node: FastTrackTest!
  cursor: String!
}

enum FastTrackTestOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  studentName_ASC
  studentName_DESC
  area_ASC
  area_DESC
  dealOwner_ASC
  dealOwner_DESC
  instructor_ASC
  instructor_DESC
  testCentrePrimary_ASC
  testCentrePrimary_DESC
  testCentreSecondary_ASC
  testCentreSecondary_DESC
  drivinglicense_ASC
  drivinglicense_DESC
  applicationRef_ASC
  applicationRef_DESC
  studentPostcode_ASC
  studentPostcode_DESC
  searchPostcode_ASC
  searchPostcode_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  booked_ASC
  booked_DESC
  bookedDate_ASC
  bookedDate_DESC
  bookedCentre_ASC
  bookedCentre_DESC
  timeWhenBooked_ASC
  timeWhenBooked_DESC
  minimumDelay_ASC
  minimumDelay_DESC
  postcode_ASC
  postcode_DESC
  stopLooking_ASC
  stopLooking_DESC
}

type FastTrackTestPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  studentName: String
  area: String
  dealOwner: String
  instructor: String
  testCentrePrimary: String
  testCentreSecondary: String
  drivinglicense: String!
  applicationRef: String!
  studentPostcode: String
  searchPostcode: String
  startDate: String
  endDate: String
  hoursToAvoid: [Int!]!
  daysToAvoid: [Int!]!
  datesToAvoid: [Int!]!
  testCentres: [Int!]!
  specificDays: [Int!]!
  specificDates: [Int!]!
  specificHours: [Int!]!
  booked: Boolean
  bookedDate: DateTime
  bookedCentre: Int
  timeWhenBooked: DateTime
  minimumDelay: Int
  postcode: String
  stopLooking: Boolean
}

type FastTrackTestSubscriptionPayload {
  mutation: MutationType!
  node: FastTrackTest
  updatedFields: [String!]
  previousValues: FastTrackTestPreviousValues
}

input FastTrackTestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FastTrackTestWhereInput
  AND: [FastTrackTestSubscriptionWhereInput!]
  OR: [FastTrackTestSubscriptionWhereInput!]
  NOT: [FastTrackTestSubscriptionWhereInput!]
}

input FastTrackTestUpdatedatesToAvoidInput {
  set: [Int!]
}

input FastTrackTestUpdatedaysToAvoidInput {
  set: [Int!]
}

input FastTrackTestUpdatehoursToAvoidInput {
  set: [Int!]
}

input FastTrackTestUpdateInput {
  studentName: String
  area: String
  dealOwner: String
  instructor: String
  testCentrePrimary: String
  testCentreSecondary: String
  drivinglicense: String
  applicationRef: String
  studentPostcode: String
  searchPostcode: String
  startDate: String
  endDate: String
  hoursToAvoid: FastTrackTestUpdatehoursToAvoidInput
  daysToAvoid: FastTrackTestUpdatedaysToAvoidInput
  datesToAvoid: FastTrackTestUpdatedatesToAvoidInput
  testCentres: FastTrackTestUpdatetestCentresInput
  specificDays: FastTrackTestUpdatespecificDaysInput
  specificDates: FastTrackTestUpdatespecificDatesInput
  specificHours: FastTrackTestUpdatespecificHoursInput
  booked: Boolean
  bookedDate: DateTime
  bookedCentre: Int
  timeWhenBooked: DateTime
  minimumDelay: Int
  postcode: String
  stopLooking: Boolean
}

input FastTrackTestUpdateManyMutationInput {
  studentName: String
  area: String
  dealOwner: String
  instructor: String
  testCentrePrimary: String
  testCentreSecondary: String
  drivinglicense: String
  applicationRef: String
  studentPostcode: String
  searchPostcode: String
  startDate: String
  endDate: String
  hoursToAvoid: FastTrackTestUpdatehoursToAvoidInput
  daysToAvoid: FastTrackTestUpdatedaysToAvoidInput
  datesToAvoid: FastTrackTestUpdatedatesToAvoidInput
  testCentres: FastTrackTestUpdatetestCentresInput
  specificDays: FastTrackTestUpdatespecificDaysInput
  specificDates: FastTrackTestUpdatespecificDatesInput
  specificHours: FastTrackTestUpdatespecificHoursInput
  booked: Boolean
  bookedDate: DateTime
  bookedCentre: Int
  timeWhenBooked: DateTime
  minimumDelay: Int
  postcode: String
  stopLooking: Boolean
}

input FastTrackTestUpdatespecificDatesInput {
  set: [Int!]
}

input FastTrackTestUpdatespecificDaysInput {
  set: [Int!]
}

input FastTrackTestUpdatespecificHoursInput {
  set: [Int!]
}

input FastTrackTestUpdatetestCentresInput {
  set: [Int!]
}

input FastTrackTestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  studentName: String
  studentName_not: String
  studentName_in: [String!]
  studentName_not_in: [String!]
  studentName_lt: String
  studentName_lte: String
  studentName_gt: String
  studentName_gte: String
  studentName_contains: String
  studentName_not_contains: String
  studentName_starts_with: String
  studentName_not_starts_with: String
  studentName_ends_with: String
  studentName_not_ends_with: String
  area: String
  area_not: String
  area_in: [String!]
  area_not_in: [String!]
  area_lt: String
  area_lte: String
  area_gt: String
  area_gte: String
  area_contains: String
  area_not_contains: String
  area_starts_with: String
  area_not_starts_with: String
  area_ends_with: String
  area_not_ends_with: String
  dealOwner: String
  dealOwner_not: String
  dealOwner_in: [String!]
  dealOwner_not_in: [String!]
  dealOwner_lt: String
  dealOwner_lte: String
  dealOwner_gt: String
  dealOwner_gte: String
  dealOwner_contains: String
  dealOwner_not_contains: String
  dealOwner_starts_with: String
  dealOwner_not_starts_with: String
  dealOwner_ends_with: String
  dealOwner_not_ends_with: String
  instructor: String
  instructor_not: String
  instructor_in: [String!]
  instructor_not_in: [String!]
  instructor_lt: String
  instructor_lte: String
  instructor_gt: String
  instructor_gte: String
  instructor_contains: String
  instructor_not_contains: String
  instructor_starts_with: String
  instructor_not_starts_with: String
  instructor_ends_with: String
  instructor_not_ends_with: String
  testCentrePrimary: String
  testCentrePrimary_not: String
  testCentrePrimary_in: [String!]
  testCentrePrimary_not_in: [String!]
  testCentrePrimary_lt: String
  testCentrePrimary_lte: String
  testCentrePrimary_gt: String
  testCentrePrimary_gte: String
  testCentrePrimary_contains: String
  testCentrePrimary_not_contains: String
  testCentrePrimary_starts_with: String
  testCentrePrimary_not_starts_with: String
  testCentrePrimary_ends_with: String
  testCentrePrimary_not_ends_with: String
  testCentreSecondary: String
  testCentreSecondary_not: String
  testCentreSecondary_in: [String!]
  testCentreSecondary_not_in: [String!]
  testCentreSecondary_lt: String
  testCentreSecondary_lte: String
  testCentreSecondary_gt: String
  testCentreSecondary_gte: String
  testCentreSecondary_contains: String
  testCentreSecondary_not_contains: String
  testCentreSecondary_starts_with: String
  testCentreSecondary_not_starts_with: String
  testCentreSecondary_ends_with: String
  testCentreSecondary_not_ends_with: String
  drivinglicense: String
  drivinglicense_not: String
  drivinglicense_in: [String!]
  drivinglicense_not_in: [String!]
  drivinglicense_lt: String
  drivinglicense_lte: String
  drivinglicense_gt: String
  drivinglicense_gte: String
  drivinglicense_contains: String
  drivinglicense_not_contains: String
  drivinglicense_starts_with: String
  drivinglicense_not_starts_with: String
  drivinglicense_ends_with: String
  drivinglicense_not_ends_with: String
  applicationRef: String
  applicationRef_not: String
  applicationRef_in: [String!]
  applicationRef_not_in: [String!]
  applicationRef_lt: String
  applicationRef_lte: String
  applicationRef_gt: String
  applicationRef_gte: String
  applicationRef_contains: String
  applicationRef_not_contains: String
  applicationRef_starts_with: String
  applicationRef_not_starts_with: String
  applicationRef_ends_with: String
  applicationRef_not_ends_with: String
  studentPostcode: String
  studentPostcode_not: String
  studentPostcode_in: [String!]
  studentPostcode_not_in: [String!]
  studentPostcode_lt: String
  studentPostcode_lte: String
  studentPostcode_gt: String
  studentPostcode_gte: String
  studentPostcode_contains: String
  studentPostcode_not_contains: String
  studentPostcode_starts_with: String
  studentPostcode_not_starts_with: String
  studentPostcode_ends_with: String
  studentPostcode_not_ends_with: String
  searchPostcode: String
  searchPostcode_not: String
  searchPostcode_in: [String!]
  searchPostcode_not_in: [String!]
  searchPostcode_lt: String
  searchPostcode_lte: String
  searchPostcode_gt: String
  searchPostcode_gte: String
  searchPostcode_contains: String
  searchPostcode_not_contains: String
  searchPostcode_starts_with: String
  searchPostcode_not_starts_with: String
  searchPostcode_ends_with: String
  searchPostcode_not_ends_with: String
  startDate: String
  startDate_not: String
  startDate_in: [String!]
  startDate_not_in: [String!]
  startDate_lt: String
  startDate_lte: String
  startDate_gt: String
  startDate_gte: String
  startDate_contains: String
  startDate_not_contains: String
  startDate_starts_with: String
  startDate_not_starts_with: String
  startDate_ends_with: String
  startDate_not_ends_with: String
  endDate: String
  endDate_not: String
  endDate_in: [String!]
  endDate_not_in: [String!]
  endDate_lt: String
  endDate_lte: String
  endDate_gt: String
  endDate_gte: String
  endDate_contains: String
  endDate_not_contains: String
  endDate_starts_with: String
  endDate_not_starts_with: String
  endDate_ends_with: String
  endDate_not_ends_with: String
  booked: Boolean
  booked_not: Boolean
  bookedDate: DateTime
  bookedDate_not: DateTime
  bookedDate_in: [DateTime!]
  bookedDate_not_in: [DateTime!]
  bookedDate_lt: DateTime
  bookedDate_lte: DateTime
  bookedDate_gt: DateTime
  bookedDate_gte: DateTime
  bookedCentre: Int
  bookedCentre_not: Int
  bookedCentre_in: [Int!]
  bookedCentre_not_in: [Int!]
  bookedCentre_lt: Int
  bookedCentre_lte: Int
  bookedCentre_gt: Int
  bookedCentre_gte: Int
  timeWhenBooked: DateTime
  timeWhenBooked_not: DateTime
  timeWhenBooked_in: [DateTime!]
  timeWhenBooked_not_in: [DateTime!]
  timeWhenBooked_lt: DateTime
  timeWhenBooked_lte: DateTime
  timeWhenBooked_gt: DateTime
  timeWhenBooked_gte: DateTime
  minimumDelay: Int
  minimumDelay_not: Int
  minimumDelay_in: [Int!]
  minimumDelay_not_in: [Int!]
  minimumDelay_lt: Int
  minimumDelay_lte: Int
  minimumDelay_gt: Int
  minimumDelay_gte: Int
  postcode: String
  postcode_not: String
  postcode_in: [String!]
  postcode_not_in: [String!]
  postcode_lt: String
  postcode_lte: String
  postcode_gt: String
  postcode_gte: String
  postcode_contains: String
  postcode_not_contains: String
  postcode_starts_with: String
  postcode_not_starts_with: String
  postcode_ends_with: String
  postcode_not_ends_with: String
  stopLooking: Boolean
  stopLooking_not: Boolean
  AND: [FastTrackTestWhereInput!]
  OR: [FastTrackTestWhereInput!]
  NOT: [FastTrackTestWhereInput!]
}

input FastTrackTestWhereUniqueInput {
  id: ID
  drivinglicense: String
  applicationRef: String
}

type Instructor {
  id: ID!
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  zenId: Int
  debt(where: DebtWhereInput, orderBy: DebtOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Debt!]
  name: String!
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

type InstructorConnection {
  pageInfo: PageInfo!
  edges: [InstructorEdge]!
  aggregate: AggregateInstructor!
}

input InstructorCreateInput {
  bookings: BookingCreateManyWithoutInstructorInput
  zenId: Int
  debt: DebtCreateManyWithoutInstructorInput
  name: String!
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorCreateManyWithoutBookingsInput {
  create: [InstructorCreateWithoutBookingsInput!]
  connect: [InstructorWhereUniqueInput!]
}

input InstructorCreateOneWithoutDebtInput {
  create: InstructorCreateWithoutDebtInput
  connect: InstructorWhereUniqueInput
}

input InstructorCreateWithoutBookingsInput {
  zenId: Int
  debt: DebtCreateManyWithoutInstructorInput
  name: String!
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorCreateWithoutDebtInput {
  bookings: BookingCreateManyWithoutInstructorInput
  zenId: Int
  name: String!
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

type InstructorEdge {
  node: Instructor!
  cursor: String!
}

enum InstructorOrderByInput {
  id_ASC
  id_DESC
  zenId_ASC
  zenId_DESC
  name_ASC
  name_DESC
  joinedOn_ASC
  joinedOn_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
  city_ASC
  city_DESC
  address_ASC
  address_DESC
  postcode_ASC
  postcode_DESC
}

type InstructorPreviousValues {
  id: ID!
  zenId: Int
  name: String!
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  zenId: Int
  zenId_not: Int
  zenId_in: [Int!]
  zenId_not_in: [Int!]
  zenId_lt: Int
  zenId_lte: Int
  zenId_gt: Int
  zenId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  joinedOn: DateTime
  joinedOn_not: DateTime
  joinedOn_in: [DateTime!]
  joinedOn_not_in: [DateTime!]
  joinedOn_lt: DateTime
  joinedOn_lte: DateTime
  joinedOn_gt: DateTime
  joinedOn_gte: DateTime
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  postcode: String
  postcode_not: String
  postcode_in: [String!]
  postcode_not_in: [String!]
  postcode_lt: String
  postcode_lte: String
  postcode_gt: String
  postcode_gte: String
  postcode_contains: String
  postcode_not_contains: String
  postcode_starts_with: String
  postcode_not_starts_with: String
  postcode_ends_with: String
  postcode_not_ends_with: String
  AND: [InstructorScalarWhereInput!]
  OR: [InstructorScalarWhereInput!]
  NOT: [InstructorScalarWhereInput!]
}

type InstructorSubscriptionPayload {
  mutation: MutationType!
  node: Instructor
  updatedFields: [String!]
  previousValues: InstructorPreviousValues
}

input InstructorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InstructorWhereInput
  AND: [InstructorSubscriptionWhereInput!]
  OR: [InstructorSubscriptionWhereInput!]
  NOT: [InstructorSubscriptionWhereInput!]
}

input InstructorUpdateInput {
  bookings: BookingUpdateManyWithoutInstructorInput
  zenId: Int
  debt: DebtUpdateManyWithoutInstructorInput
  name: String
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorUpdateManyDataInput {
  zenId: Int
  name: String
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorUpdateManyMutationInput {
  zenId: Int
  name: String
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorUpdateManyWithoutBookingsInput {
  create: [InstructorCreateWithoutBookingsInput!]
  delete: [InstructorWhereUniqueInput!]
  connect: [InstructorWhereUniqueInput!]
  set: [InstructorWhereUniqueInput!]
  disconnect: [InstructorWhereUniqueInput!]
  update: [InstructorUpdateWithWhereUniqueWithoutBookingsInput!]
  upsert: [InstructorUpsertWithWhereUniqueWithoutBookingsInput!]
  deleteMany: [InstructorScalarWhereInput!]
  updateMany: [InstructorUpdateManyWithWhereNestedInput!]
}

input InstructorUpdateManyWithWhereNestedInput {
  where: InstructorScalarWhereInput!
  data: InstructorUpdateManyDataInput!
}

input InstructorUpdateOneRequiredWithoutDebtInput {
  create: InstructorCreateWithoutDebtInput
  update: InstructorUpdateWithoutDebtDataInput
  upsert: InstructorUpsertWithoutDebtInput
  connect: InstructorWhereUniqueInput
}

input InstructorUpdateWithoutBookingsDataInput {
  zenId: Int
  debt: DebtUpdateManyWithoutInstructorInput
  name: String
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorUpdateWithoutDebtDataInput {
  bookings: BookingUpdateManyWithoutInstructorInput
  zenId: Int
  name: String
  joinedOn: DateTime
  phone: String
  email: String
  city: String
  address: String
  postcode: String
}

input InstructorUpdateWithWhereUniqueWithoutBookingsInput {
  where: InstructorWhereUniqueInput!
  data: InstructorUpdateWithoutBookingsDataInput!
}

input InstructorUpsertWithoutDebtInput {
  update: InstructorUpdateWithoutDebtDataInput!
  create: InstructorCreateWithoutDebtInput!
}

input InstructorUpsertWithWhereUniqueWithoutBookingsInput {
  where: InstructorWhereUniqueInput!
  update: InstructorUpdateWithoutBookingsDataInput!
  create: InstructorCreateWithoutBookingsInput!
}

input InstructorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
  zenId: Int
  zenId_not: Int
  zenId_in: [Int!]
  zenId_not_in: [Int!]
  zenId_lt: Int
  zenId_lte: Int
  zenId_gt: Int
  zenId_gte: Int
  debt_every: DebtWhereInput
  debt_some: DebtWhereInput
  debt_none: DebtWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  joinedOn: DateTime
  joinedOn_not: DateTime
  joinedOn_in: [DateTime!]
  joinedOn_not_in: [DateTime!]
  joinedOn_lt: DateTime
  joinedOn_lte: DateTime
  joinedOn_gt: DateTime
  joinedOn_gte: DateTime
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  postcode: String
  postcode_not: String
  postcode_in: [String!]
  postcode_not_in: [String!]
  postcode_lt: String
  postcode_lte: String
  postcode_gt: String
  postcode_gte: String
  postcode_contains: String
  postcode_not_contains: String
  postcode_starts_with: String
  postcode_not_starts_with: String
  postcode_ends_with: String
  postcode_not_ends_with: String
  AND: [InstructorWhereInput!]
  OR: [InstructorWhereInput!]
  NOT: [InstructorWhereInput!]
}

input InstructorWhereUniqueInput {
  id: ID
  zenId: Int
}

type LatestHistoryId {
  id: ID!
  latestId: String
  reference: String
}

type LatestHistoryIdConnection {
  pageInfo: PageInfo!
  edges: [LatestHistoryIdEdge]!
  aggregate: AggregateLatestHistoryId!
}

input LatestHistoryIdCreateInput {
  latestId: String
  reference: String
}

type LatestHistoryIdEdge {
  node: LatestHistoryId!
  cursor: String!
}

enum LatestHistoryIdOrderByInput {
  id_ASC
  id_DESC
  latestId_ASC
  latestId_DESC
  reference_ASC
  reference_DESC
}

type LatestHistoryIdPreviousValues {
  id: ID!
  latestId: String
  reference: String
}

type LatestHistoryIdSubscriptionPayload {
  mutation: MutationType!
  node: LatestHistoryId
  updatedFields: [String!]
  previousValues: LatestHistoryIdPreviousValues
}

input LatestHistoryIdSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LatestHistoryIdWhereInput
  AND: [LatestHistoryIdSubscriptionWhereInput!]
  OR: [LatestHistoryIdSubscriptionWhereInput!]
  NOT: [LatestHistoryIdSubscriptionWhereInput!]
}

input LatestHistoryIdUpdateInput {
  latestId: String
  reference: String
}

input LatestHistoryIdUpdateManyMutationInput {
  latestId: String
  reference: String
}

input LatestHistoryIdWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  latestId: String
  latestId_not: String
  latestId_in: [String!]
  latestId_not_in: [String!]
  latestId_lt: String
  latestId_lte: String
  latestId_gt: String
  latestId_gte: String
  latestId_contains: String
  latestId_not_contains: String
  latestId_starts_with: String
  latestId_not_starts_with: String
  latestId_ends_with: String
  latestId_not_ends_with: String
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  AND: [LatestHistoryIdWhereInput!]
  OR: [LatestHistoryIdWhereInput!]
  NOT: [LatestHistoryIdWhereInput!]
}

input LatestHistoryIdWhereUniqueInput {
  id: ID
  latestId: String
  reference: String
}

scalar Long

type Mutation {
  createAgent(data: AgentCreateInput!): Agent!
  updateAgent(data: AgentUpdateInput!, where: AgentWhereUniqueInput!): Agent
  updateManyAgents(data: AgentUpdateManyMutationInput!, where: AgentWhereInput): BatchPayload!
  upsertAgent(where: AgentWhereUniqueInput!, create: AgentCreateInput!, update: AgentUpdateInput!): Agent!
  deleteAgent(where: AgentWhereUniqueInput!): Agent
  deleteManyAgents(where: AgentWhereInput): BatchPayload!
  createBooking(data: BookingCreateInput!): Booking!
  updateBooking(data: BookingUpdateInput!, where: BookingWhereUniqueInput!): Booking
  updateManyBookings(data: BookingUpdateManyMutationInput!, where: BookingWhereInput): BatchPayload!
  upsertBooking(where: BookingWhereUniqueInput!, create: BookingCreateInput!, update: BookingUpdateInput!): Booking!
  deleteBooking(where: BookingWhereUniqueInput!): Booking
  deleteManyBookings(where: BookingWhereInput): BatchPayload!
  createDebt(data: DebtCreateInput!): Debt!
  updateDebt(data: DebtUpdateInput!, where: DebtWhereUniqueInput!): Debt
  updateManyDebts(data: DebtUpdateManyMutationInput!, where: DebtWhereInput): BatchPayload!
  upsertDebt(where: DebtWhereUniqueInput!, create: DebtCreateInput!, update: DebtUpdateInput!): Debt!
  deleteDebt(where: DebtWhereUniqueInput!): Debt
  deleteManyDebts(where: DebtWhereInput): BatchPayload!
  createDebtChase(data: DebtChaseCreateInput!): DebtChase!
  updateDebtChase(data: DebtChaseUpdateInput!, where: DebtChaseWhereUniqueInput!): DebtChase
  updateManyDebtChases(data: DebtChaseUpdateManyMutationInput!, where: DebtChaseWhereInput): BatchPayload!
  upsertDebtChase(where: DebtChaseWhereUniqueInput!, create: DebtChaseCreateInput!, update: DebtChaseUpdateInput!): DebtChase!
  deleteDebtChase(where: DebtChaseWhereUniqueInput!): DebtChase
  deleteManyDebtChases(where: DebtChaseWhereInput): BatchPayload!
  createFastTrackTest(data: FastTrackTestCreateInput!): FastTrackTest!
  updateFastTrackTest(data: FastTrackTestUpdateInput!, where: FastTrackTestWhereUniqueInput!): FastTrackTest
  updateManyFastTrackTests(data: FastTrackTestUpdateManyMutationInput!, where: FastTrackTestWhereInput): BatchPayload!
  upsertFastTrackTest(where: FastTrackTestWhereUniqueInput!, create: FastTrackTestCreateInput!, update: FastTrackTestUpdateInput!): FastTrackTest!
  deleteFastTrackTest(where: FastTrackTestWhereUniqueInput!): FastTrackTest
  deleteManyFastTrackTests(where: FastTrackTestWhereInput): BatchPayload!
  createInstructor(data: InstructorCreateInput!): Instructor!
  updateInstructor(data: InstructorUpdateInput!, where: InstructorWhereUniqueInput!): Instructor
  updateManyInstructors(data: InstructorUpdateManyMutationInput!, where: InstructorWhereInput): BatchPayload!
  upsertInstructor(where: InstructorWhereUniqueInput!, create: InstructorCreateInput!, update: InstructorUpdateInput!): Instructor!
  deleteInstructor(where: InstructorWhereUniqueInput!): Instructor
  deleteManyInstructors(where: InstructorWhereInput): BatchPayload!
  createLatestHistoryId(data: LatestHistoryIdCreateInput!): LatestHistoryId!
  updateLatestHistoryId(data: LatestHistoryIdUpdateInput!, where: LatestHistoryIdWhereUniqueInput!): LatestHistoryId
  updateManyLatestHistoryIds(data: LatestHistoryIdUpdateManyMutationInput!, where: LatestHistoryIdWhereInput): BatchPayload!
  upsertLatestHistoryId(where: LatestHistoryIdWhereUniqueInput!, create: LatestHistoryIdCreateInput!, update: LatestHistoryIdUpdateInput!): LatestHistoryId!
  deleteLatestHistoryId(where: LatestHistoryIdWhereUniqueInput!): LatestHistoryId
  deleteManyLatestHistoryIds(where: LatestHistoryIdWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createPracticalTest(data: PracticalTestCreateInput!): PracticalTest!
  updatePracticalTest(data: PracticalTestUpdateInput!, where: PracticalTestWhereUniqueInput!): PracticalTest
  updateManyPracticalTests(data: PracticalTestUpdateManyMutationInput!, where: PracticalTestWhereInput): BatchPayload!
  upsertPracticalTest(where: PracticalTestWhereUniqueInput!, create: PracticalTestCreateInput!, update: PracticalTestUpdateInput!): PracticalTest!
  deletePracticalTest(where: PracticalTestWhereUniqueInput!): PracticalTest
  deleteManyPracticalTests(where: PracticalTestWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  paidOn: DateTime
  debt: Debt!
  amount: Float!
  notes: String
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  paidOn: DateTime
  debt: DebtCreateOneWithoutPaymentsInput!
  amount: Float!
  notes: String
}

input PaymentCreateManyWithoutDebtInput {
  create: [PaymentCreateWithoutDebtInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateWithoutDebtInput {
  paidOn: DateTime
  amount: Float!
  notes: String
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  paidOn_ASC
  paidOn_DESC
  amount_ASC
  amount_DESC
  notes_ASC
  notes_DESC
}

type PaymentPreviousValues {
  id: ID!
  paidOn: DateTime
  amount: Float!
  notes: String
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  paidOn: DateTime
  paidOn_not: DateTime
  paidOn_in: [DateTime!]
  paidOn_not_in: [DateTime!]
  paidOn_lt: DateTime
  paidOn_lte: DateTime
  paidOn_gt: DateTime
  paidOn_gte: DateTime
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  paidOn: DateTime
  debt: DebtUpdateOneRequiredWithoutPaymentsInput
  amount: Float
  notes: String
}

input PaymentUpdateManyDataInput {
  paidOn: DateTime
  amount: Float
  notes: String
}

input PaymentUpdateManyMutationInput {
  paidOn: DateTime
  amount: Float
  notes: String
}

input PaymentUpdateManyWithoutDebtInput {
  create: [PaymentCreateWithoutDebtInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutDebtInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutDebtInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateWithoutDebtDataInput {
  paidOn: DateTime
  amount: Float
  notes: String
}

input PaymentUpdateWithWhereUniqueWithoutDebtInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutDebtDataInput!
}

input PaymentUpsertWithWhereUniqueWithoutDebtInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutDebtDataInput!
  create: PaymentCreateWithoutDebtInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  paidOn: DateTime
  paidOn_not: DateTime
  paidOn_in: [DateTime!]
  paidOn_not_in: [DateTime!]
  paidOn_lt: DateTime
  paidOn_lte: DateTime
  paidOn_gt: DateTime
  paidOn_gte: DateTime
  debt: DebtWhereInput
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type PracticalTest {
  id: ID!
  gmailId: String
  checkTelephone: String
  studentName: String
  location: String
  testDate: DateTime
  lastChangeDate: DateTime
  reference: String!
  booking: Booking
  emailContent: String
  isConfirmed: Boolean!
  status: PracticalTestStatus!
}

type PracticalTestConnection {
  pageInfo: PageInfo!
  edges: [PracticalTestEdge]!
  aggregate: AggregatePracticalTest!
}

input PracticalTestCreateInput {
  gmailId: String
  checkTelephone: String
  studentName: String
  location: String
  testDate: DateTime
  lastChangeDate: DateTime
  reference: String!
  booking: BookingCreateOneInput
  emailContent: String
  isConfirmed: Boolean
  status: PracticalTestStatus
}

type PracticalTestEdge {
  node: PracticalTest!
  cursor: String!
}

enum PracticalTestOrderByInput {
  id_ASC
  id_DESC
  gmailId_ASC
  gmailId_DESC
  checkTelephone_ASC
  checkTelephone_DESC
  studentName_ASC
  studentName_DESC
  location_ASC
  location_DESC
  testDate_ASC
  testDate_DESC
  lastChangeDate_ASC
  lastChangeDate_DESC
  reference_ASC
  reference_DESC
  emailContent_ASC
  emailContent_DESC
  isConfirmed_ASC
  isConfirmed_DESC
  status_ASC
  status_DESC
}

type PracticalTestPreviousValues {
  id: ID!
  gmailId: String
  checkTelephone: String
  studentName: String
  location: String
  testDate: DateTime
  lastChangeDate: DateTime
  reference: String!
  emailContent: String
  isConfirmed: Boolean!
  status: PracticalTestStatus!
}

enum PracticalTestStatus {
  NEEDSCONFIRMING
  CONFIRMED
  CHANGED
}

type PracticalTestSubscriptionPayload {
  mutation: MutationType!
  node: PracticalTest
  updatedFields: [String!]
  previousValues: PracticalTestPreviousValues
}

input PracticalTestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PracticalTestWhereInput
  AND: [PracticalTestSubscriptionWhereInput!]
  OR: [PracticalTestSubscriptionWhereInput!]
  NOT: [PracticalTestSubscriptionWhereInput!]
}

input PracticalTestUpdateInput {
  gmailId: String
  checkTelephone: String
  studentName: String
  location: String
  testDate: DateTime
  lastChangeDate: DateTime
  reference: String
  booking: BookingUpdateOneInput
  emailContent: String
  isConfirmed: Boolean
  status: PracticalTestStatus
}

input PracticalTestUpdateManyMutationInput {
  gmailId: String
  checkTelephone: String
  studentName: String
  location: String
  testDate: DateTime
  lastChangeDate: DateTime
  reference: String
  emailContent: String
  isConfirmed: Boolean
  status: PracticalTestStatus
}

input PracticalTestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  gmailId: String
  gmailId_not: String
  gmailId_in: [String!]
  gmailId_not_in: [String!]
  gmailId_lt: String
  gmailId_lte: String
  gmailId_gt: String
  gmailId_gte: String
  gmailId_contains: String
  gmailId_not_contains: String
  gmailId_starts_with: String
  gmailId_not_starts_with: String
  gmailId_ends_with: String
  gmailId_not_ends_with: String
  checkTelephone: String
  checkTelephone_not: String
  checkTelephone_in: [String!]
  checkTelephone_not_in: [String!]
  checkTelephone_lt: String
  checkTelephone_lte: String
  checkTelephone_gt: String
  checkTelephone_gte: String
  checkTelephone_contains: String
  checkTelephone_not_contains: String
  checkTelephone_starts_with: String
  checkTelephone_not_starts_with: String
  checkTelephone_ends_with: String
  checkTelephone_not_ends_with: String
  studentName: String
  studentName_not: String
  studentName_in: [String!]
  studentName_not_in: [String!]
  studentName_lt: String
  studentName_lte: String
  studentName_gt: String
  studentName_gte: String
  studentName_contains: String
  studentName_not_contains: String
  studentName_starts_with: String
  studentName_not_starts_with: String
  studentName_ends_with: String
  studentName_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  testDate: DateTime
  testDate_not: DateTime
  testDate_in: [DateTime!]
  testDate_not_in: [DateTime!]
  testDate_lt: DateTime
  testDate_lte: DateTime
  testDate_gt: DateTime
  testDate_gte: DateTime
  lastChangeDate: DateTime
  lastChangeDate_not: DateTime
  lastChangeDate_in: [DateTime!]
  lastChangeDate_not_in: [DateTime!]
  lastChangeDate_lt: DateTime
  lastChangeDate_lte: DateTime
  lastChangeDate_gt: DateTime
  lastChangeDate_gte: DateTime
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  booking: BookingWhereInput
  emailContent: String
  emailContent_not: String
  emailContent_in: [String!]
  emailContent_not_in: [String!]
  emailContent_lt: String
  emailContent_lte: String
  emailContent_gt: String
  emailContent_gte: String
  emailContent_contains: String
  emailContent_not_contains: String
  emailContent_starts_with: String
  emailContent_not_starts_with: String
  emailContent_ends_with: String
  emailContent_not_ends_with: String
  isConfirmed: Boolean
  isConfirmed_not: Boolean
  status: PracticalTestStatus
  status_not: PracticalTestStatus
  status_in: [PracticalTestStatus!]
  status_not_in: [PracticalTestStatus!]
  AND: [PracticalTestWhereInput!]
  OR: [PracticalTestWhereInput!]
  NOT: [PracticalTestWhereInput!]
}

input PracticalTestWhereUniqueInput {
  id: ID
  gmailId: String
  studentName: String
  reference: String
}

type Query {
  agent(where: AgentWhereUniqueInput!): Agent
  agents(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Agent]!
  agentsConnection(where: AgentWhereInput, orderBy: AgentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AgentConnection!
  booking(where: BookingWhereUniqueInput!): Booking
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking]!
  bookingsConnection(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookingConnection!
  debt(where: DebtWhereUniqueInput!): Debt
  debts(where: DebtWhereInput, orderBy: DebtOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Debt]!
  debtsConnection(where: DebtWhereInput, orderBy: DebtOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DebtConnection!
  debtChase(where: DebtChaseWhereUniqueInput!): DebtChase
  debtChases(where: DebtChaseWhereInput, orderBy: DebtChaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DebtChase]!
  debtChasesConnection(where: DebtChaseWhereInput, orderBy: DebtChaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DebtChaseConnection!
  fastTrackTest(where: FastTrackTestWhereUniqueInput!): FastTrackTest
  fastTrackTests(where: FastTrackTestWhereInput, orderBy: FastTrackTestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FastTrackTest]!
  fastTrackTestsConnection(where: FastTrackTestWhereInput, orderBy: FastTrackTestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FastTrackTestConnection!
  instructor(where: InstructorWhereUniqueInput!): Instructor
  instructors(where: InstructorWhereInput, orderBy: InstructorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Instructor]!
  instructorsConnection(where: InstructorWhereInput, orderBy: InstructorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InstructorConnection!
  latestHistoryId(where: LatestHistoryIdWhereUniqueInput!): LatestHistoryId
  latestHistoryIds(where: LatestHistoryIdWhereInput, orderBy: LatestHistoryIdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LatestHistoryId]!
  latestHistoryIdsConnection(where: LatestHistoryIdWhereInput, orderBy: LatestHistoryIdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LatestHistoryIdConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  practicalTest(where: PracticalTestWhereUniqueInput!): PracticalTest
  practicalTests(where: PracticalTestWhereInput, orderBy: PracticalTestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PracticalTest]!
  practicalTestsConnection(where: PracticalTestWhereInput, orderBy: PracticalTestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PracticalTestConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  node(id: ID!): Node
}

type Student {
  id: ID!
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  zenId: Int
  name: String!
  phone: String
  email: String
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  bookings: BookingCreateManyWithoutStudentInput
  zenId: Int
  name: String!
  phone: String
  email: String
}

input StudentCreateOneWithoutBookingsInput {
  create: StudentCreateWithoutBookingsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutBookingsInput {
  zenId: Int
  name: String!
  phone: String
  email: String
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  zenId_ASC
  zenId_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  email_ASC
  email_DESC
}

type StudentPreviousValues {
  id: ID!
  zenId: Int
  name: String!
  phone: String
  email: String
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateInput {
  bookings: BookingUpdateManyWithoutStudentInput
  zenId: Int
  name: String
  phone: String
  email: String
}

input StudentUpdateManyMutationInput {
  zenId: Int
  name: String
  phone: String
  email: String
}

input StudentUpdateOneWithoutBookingsInput {
  create: StudentCreateWithoutBookingsInput
  update: StudentUpdateWithoutBookingsDataInput
  upsert: StudentUpsertWithoutBookingsInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutBookingsDataInput {
  zenId: Int
  name: String
  phone: String
  email: String
}

input StudentUpsertWithoutBookingsInput {
  update: StudentUpdateWithoutBookingsDataInput!
  create: StudentCreateWithoutBookingsInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
  zenId: Int
  zenId_not: Int
  zenId_in: [Int!]
  zenId_not_in: [Int!]
  zenId_lt: Int
  zenId_lte: Int
  zenId_gt: Int
  zenId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
  zenId: Int
}

type Subscription {
  agent(where: AgentSubscriptionWhereInput): AgentSubscriptionPayload
  booking(where: BookingSubscriptionWhereInput): BookingSubscriptionPayload
  debt(where: DebtSubscriptionWhereInput): DebtSubscriptionPayload
  debtChase(where: DebtChaseSubscriptionWhereInput): DebtChaseSubscriptionPayload
  fastTrackTest(where: FastTrackTestSubscriptionWhereInput): FastTrackTestSubscriptionPayload
  instructor(where: InstructorSubscriptionWhereInput): InstructorSubscriptionPayload
  latestHistoryId(where: LatestHistoryIdSubscriptionWhereInput): LatestHistoryIdSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  practicalTest(where: PracticalTestSubscriptionWhereInput): PracticalTestSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
}
`