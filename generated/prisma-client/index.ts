// Code generated by Prisma (prisma@1.31.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  agent: (where?: AgentWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  debt: (where?: DebtWhereInput) => Promise<boolean>;
  debtChase: (where?: DebtChaseWhereInput) => Promise<boolean>;
  fastTrackTest: (where?: FastTrackTestWhereInput) => Promise<boolean>;
  instructor: (where?: InstructorWhereInput) => Promise<boolean>;
  latestHistoryId: (where?: LatestHistoryIdWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  practicalTest: (where?: PracticalTestWhereInput) => Promise<boolean>;
  proxy: (where?: ProxyWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  testCentre: (where?: TestCentreWhereInput) => Promise<boolean>;
  unavailabilityWindow: (
    where?: UnavailabilityWindowWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  agent: (where: AgentWhereUniqueInput) => AgentPromise;
  agents: (args?: {
    where?: AgentWhereInput;
    orderBy?: AgentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Agent>;
  agentsConnection: (args?: {
    where?: AgentWhereInput;
    orderBy?: AgentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgentConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingPromise;
  bookings: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Booking>;
  bookingsConnection: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookingConnectionPromise;
  debt: (where: DebtWhereUniqueInput) => DebtPromise;
  debts: (args?: {
    where?: DebtWhereInput;
    orderBy?: DebtOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Debt>;
  debtsConnection: (args?: {
    where?: DebtWhereInput;
    orderBy?: DebtOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DebtConnectionPromise;
  debtChase: (where: DebtChaseWhereUniqueInput) => DebtChasePromise;
  debtChases: (args?: {
    where?: DebtChaseWhereInput;
    orderBy?: DebtChaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DebtChase>;
  debtChasesConnection: (args?: {
    where?: DebtChaseWhereInput;
    orderBy?: DebtChaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DebtChaseConnectionPromise;
  fastTrackTest: (where: FastTrackTestWhereUniqueInput) => FastTrackTestPromise;
  fastTrackTests: (args?: {
    where?: FastTrackTestWhereInput;
    orderBy?: FastTrackTestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FastTrackTest>;
  fastTrackTestsConnection: (args?: {
    where?: FastTrackTestWhereInput;
    orderBy?: FastTrackTestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FastTrackTestConnectionPromise;
  instructor: (where: InstructorWhereUniqueInput) => InstructorPromise;
  instructors: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Instructor>;
  instructorsConnection: (args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InstructorConnectionPromise;
  latestHistoryId: (
    where: LatestHistoryIdWhereUniqueInput
  ) => LatestHistoryIdPromise;
  latestHistoryIds: (args?: {
    where?: LatestHistoryIdWhereInput;
    orderBy?: LatestHistoryIdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LatestHistoryId>;
  latestHistoryIdsConnection: (args?: {
    where?: LatestHistoryIdWhereInput;
    orderBy?: LatestHistoryIdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LatestHistoryIdConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  practicalTest: (where: PracticalTestWhereUniqueInput) => PracticalTestPromise;
  practicalTests: (args?: {
    where?: PracticalTestWhereInput;
    orderBy?: PracticalTestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PracticalTest>;
  practicalTestsConnection: (args?: {
    where?: PracticalTestWhereInput;
    orderBy?: PracticalTestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PracticalTestConnectionPromise;
  proxy: (where: ProxyWhereUniqueInput) => ProxyPromise;
  proxies: (args?: {
    where?: ProxyWhereInput;
    orderBy?: ProxyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Proxy>;
  proxiesConnection: (args?: {
    where?: ProxyWhereInput;
    orderBy?: ProxyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProxyConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  testCentre: (where: TestCentreWhereUniqueInput) => TestCentrePromise;
  testCentres: (args?: {
    where?: TestCentreWhereInput;
    orderBy?: TestCentreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TestCentre>;
  testCentresConnection: (args?: {
    where?: TestCentreWhereInput;
    orderBy?: TestCentreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestCentreConnectionPromise;
  unavailabilityWindows: (args?: {
    where?: UnavailabilityWindowWhereInput;
    orderBy?: UnavailabilityWindowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UnavailabilityWindow>;
  unavailabilityWindowsConnection: (args?: {
    where?: UnavailabilityWindowWhereInput;
    orderBy?: UnavailabilityWindowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UnavailabilityWindowConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgent: (data: AgentCreateInput) => AgentPromise;
  updateAgent: (args: {
    data: AgentUpdateInput;
    where: AgentWhereUniqueInput;
  }) => AgentPromise;
  updateManyAgents: (args: {
    data: AgentUpdateManyMutationInput;
    where?: AgentWhereInput;
  }) => BatchPayloadPromise;
  upsertAgent: (args: {
    where: AgentWhereUniqueInput;
    create: AgentCreateInput;
    update: AgentUpdateInput;
  }) => AgentPromise;
  deleteAgent: (where: AgentWhereUniqueInput) => AgentPromise;
  deleteManyAgents: (where?: AgentWhereInput) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (args: {
    data: BookingUpdateInput;
    where: BookingWhereUniqueInput;
  }) => BookingPromise;
  updateManyBookings: (args: {
    data: BookingUpdateManyMutationInput;
    where?: BookingWhereInput;
  }) => BatchPayloadPromise;
  upsertBooking: (args: {
    where: BookingWhereUniqueInput;
    create: BookingCreateInput;
    update: BookingUpdateInput;
  }) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createDebt: (data: DebtCreateInput) => DebtPromise;
  updateDebt: (args: {
    data: DebtUpdateInput;
    where: DebtWhereUniqueInput;
  }) => DebtPromise;
  updateManyDebts: (args: {
    data: DebtUpdateManyMutationInput;
    where?: DebtWhereInput;
  }) => BatchPayloadPromise;
  upsertDebt: (args: {
    where: DebtWhereUniqueInput;
    create: DebtCreateInput;
    update: DebtUpdateInput;
  }) => DebtPromise;
  deleteDebt: (where: DebtWhereUniqueInput) => DebtPromise;
  deleteManyDebts: (where?: DebtWhereInput) => BatchPayloadPromise;
  createDebtChase: (data: DebtChaseCreateInput) => DebtChasePromise;
  updateDebtChase: (args: {
    data: DebtChaseUpdateInput;
    where: DebtChaseWhereUniqueInput;
  }) => DebtChasePromise;
  updateManyDebtChases: (args: {
    data: DebtChaseUpdateManyMutationInput;
    where?: DebtChaseWhereInput;
  }) => BatchPayloadPromise;
  upsertDebtChase: (args: {
    where: DebtChaseWhereUniqueInput;
    create: DebtChaseCreateInput;
    update: DebtChaseUpdateInput;
  }) => DebtChasePromise;
  deleteDebtChase: (where: DebtChaseWhereUniqueInput) => DebtChasePromise;
  deleteManyDebtChases: (where?: DebtChaseWhereInput) => BatchPayloadPromise;
  createFastTrackTest: (data: FastTrackTestCreateInput) => FastTrackTestPromise;
  updateFastTrackTest: (args: {
    data: FastTrackTestUpdateInput;
    where: FastTrackTestWhereUniqueInput;
  }) => FastTrackTestPromise;
  updateManyFastTrackTests: (args: {
    data: FastTrackTestUpdateManyMutationInput;
    where?: FastTrackTestWhereInput;
  }) => BatchPayloadPromise;
  upsertFastTrackTest: (args: {
    where: FastTrackTestWhereUniqueInput;
    create: FastTrackTestCreateInput;
    update: FastTrackTestUpdateInput;
  }) => FastTrackTestPromise;
  deleteFastTrackTest: (
    where: FastTrackTestWhereUniqueInput
  ) => FastTrackTestPromise;
  deleteManyFastTrackTests: (
    where?: FastTrackTestWhereInput
  ) => BatchPayloadPromise;
  createInstructor: (data: InstructorCreateInput) => InstructorPromise;
  updateInstructor: (args: {
    data: InstructorUpdateInput;
    where: InstructorWhereUniqueInput;
  }) => InstructorPromise;
  updateManyInstructors: (args: {
    data: InstructorUpdateManyMutationInput;
    where?: InstructorWhereInput;
  }) => BatchPayloadPromise;
  upsertInstructor: (args: {
    where: InstructorWhereUniqueInput;
    create: InstructorCreateInput;
    update: InstructorUpdateInput;
  }) => InstructorPromise;
  deleteInstructor: (where: InstructorWhereUniqueInput) => InstructorPromise;
  deleteManyInstructors: (where?: InstructorWhereInput) => BatchPayloadPromise;
  createLatestHistoryId: (
    data: LatestHistoryIdCreateInput
  ) => LatestHistoryIdPromise;
  updateLatestHistoryId: (args: {
    data: LatestHistoryIdUpdateInput;
    where: LatestHistoryIdWhereUniqueInput;
  }) => LatestHistoryIdPromise;
  updateManyLatestHistoryIds: (args: {
    data: LatestHistoryIdUpdateManyMutationInput;
    where?: LatestHistoryIdWhereInput;
  }) => BatchPayloadPromise;
  upsertLatestHistoryId: (args: {
    where: LatestHistoryIdWhereUniqueInput;
    create: LatestHistoryIdCreateInput;
    update: LatestHistoryIdUpdateInput;
  }) => LatestHistoryIdPromise;
  deleteLatestHistoryId: (
    where: LatestHistoryIdWhereUniqueInput
  ) => LatestHistoryIdPromise;
  deleteManyLatestHistoryIds: (
    where?: LatestHistoryIdWhereInput
  ) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPracticalTest: (data: PracticalTestCreateInput) => PracticalTestPromise;
  updatePracticalTest: (args: {
    data: PracticalTestUpdateInput;
    where: PracticalTestWhereUniqueInput;
  }) => PracticalTestPromise;
  updateManyPracticalTests: (args: {
    data: PracticalTestUpdateManyMutationInput;
    where?: PracticalTestWhereInput;
  }) => BatchPayloadPromise;
  upsertPracticalTest: (args: {
    where: PracticalTestWhereUniqueInput;
    create: PracticalTestCreateInput;
    update: PracticalTestUpdateInput;
  }) => PracticalTestPromise;
  deletePracticalTest: (
    where: PracticalTestWhereUniqueInput
  ) => PracticalTestPromise;
  deleteManyPracticalTests: (
    where?: PracticalTestWhereInput
  ) => BatchPayloadPromise;
  createProxy: (data: ProxyCreateInput) => ProxyPromise;
  updateProxy: (args: {
    data: ProxyUpdateInput;
    where: ProxyWhereUniqueInput;
  }) => ProxyPromise;
  updateManyProxies: (args: {
    data: ProxyUpdateManyMutationInput;
    where?: ProxyWhereInput;
  }) => BatchPayloadPromise;
  upsertProxy: (args: {
    where: ProxyWhereUniqueInput;
    create: ProxyCreateInput;
    update: ProxyUpdateInput;
  }) => ProxyPromise;
  deleteProxy: (where: ProxyWhereUniqueInput) => ProxyPromise;
  deleteManyProxies: (where?: ProxyWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createTestCentre: (data: TestCentreCreateInput) => TestCentrePromise;
  updateTestCentre: (args: {
    data: TestCentreUpdateInput;
    where: TestCentreWhereUniqueInput;
  }) => TestCentrePromise;
  updateManyTestCentres: (args: {
    data: TestCentreUpdateManyMutationInput;
    where?: TestCentreWhereInput;
  }) => BatchPayloadPromise;
  upsertTestCentre: (args: {
    where: TestCentreWhereUniqueInput;
    create: TestCentreCreateInput;
    update: TestCentreUpdateInput;
  }) => TestCentrePromise;
  deleteTestCentre: (where: TestCentreWhereUniqueInput) => TestCentrePromise;
  deleteManyTestCentres: (where?: TestCentreWhereInput) => BatchPayloadPromise;
  createUnavailabilityWindow: (
    data: UnavailabilityWindowCreateInput
  ) => UnavailabilityWindowPromise;
  updateManyUnavailabilityWindows: (args: {
    data: UnavailabilityWindowUpdateManyMutationInput;
    where?: UnavailabilityWindowWhereInput;
  }) => BatchPayloadPromise;
  deleteManyUnavailabilityWindows: (
    where?: UnavailabilityWindowWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  agent: (
    where?: AgentSubscriptionWhereInput
  ) => AgentSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  debt: (
    where?: DebtSubscriptionWhereInput
  ) => DebtSubscriptionPayloadSubscription;
  debtChase: (
    where?: DebtChaseSubscriptionWhereInput
  ) => DebtChaseSubscriptionPayloadSubscription;
  fastTrackTest: (
    where?: FastTrackTestSubscriptionWhereInput
  ) => FastTrackTestSubscriptionPayloadSubscription;
  instructor: (
    where?: InstructorSubscriptionWhereInput
  ) => InstructorSubscriptionPayloadSubscription;
  latestHistoryId: (
    where?: LatestHistoryIdSubscriptionWhereInput
  ) => LatestHistoryIdSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  practicalTest: (
    where?: PracticalTestSubscriptionWhereInput
  ) => PracticalTestSubscriptionPayloadSubscription;
  proxy: (
    where?: ProxySubscriptionWhereInput
  ) => ProxySubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  testCentre: (
    where?: TestCentreSubscriptionWhereInput
  ) => TestCentreSubscriptionPayloadSubscription;
  unavailabilityWindow: (
    where?: UnavailabilityWindowSubscriptionWhereInput
  ) => UnavailabilityWindowSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DebtStatus =
  | "NEEDSCHASING"
  | "CHASED"
  | "PAYMENTAGREED"
  | "BADDEBT"
  | "FULLYPAID";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "zenId_ASC"
  | "zenId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "bookedAt_ASC"
  | "bookedAt_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type DebtOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "initialAmount_ASC"
  | "initialAmount_DESC"
  | "currentAmount_ASC"
  | "currentAmount_DESC"
  | "paidOff_ASC"
  | "paidOff_DESC"
  | "status_ASC"
  | "status_DESC"
  | "dueSince_ASC"
  | "dueSince_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type DebtChaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "chasedOn_ASC"
  | "chasedOn_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "paidOn_ASC"
  | "paidOn_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type InstructorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "zenId_ASC"
  | "zenId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "joinedOn_ASC"
  | "joinedOn_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "email_ASC"
  | "email_DESC"
  | "city_ASC"
  | "city_DESC"
  | "address_ASC"
  | "address_DESC"
  | "postcode_ASC"
  | "postcode_DESC";

export type AgentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "zenId_ASC"
  | "zenId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC";

export type FastTrackTestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "studentName_ASC"
  | "studentName_DESC"
  | "area_ASC"
  | "area_DESC"
  | "dealOwner_ASC"
  | "dealOwner_DESC"
  | "instructor_ASC"
  | "instructor_DESC"
  | "testCentrePrimary_ASC"
  | "testCentrePrimary_DESC"
  | "testCentreSecondary_ASC"
  | "testCentreSecondary_DESC"
  | "drivinglicense_ASC"
  | "drivinglicense_DESC"
  | "applicationRef_ASC"
  | "applicationRef_DESC"
  | "studentPostcode_ASC"
  | "studentPostcode_DESC"
  | "searchPostcode_ASC"
  | "searchPostcode_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "booked_ASC"
  | "booked_DESC"
  | "bookedDate_ASC"
  | "bookedDate_DESC"
  | "bookedCentre_ASC"
  | "bookedCentre_DESC"
  | "timeWhenBooked_ASC"
  | "timeWhenBooked_DESC"
  | "minimumDelay_ASC"
  | "minimumDelay_DESC"
  | "postcode_ASC"
  | "postcode_DESC"
  | "stopLooking_ASC"
  | "stopLooking_DESC";

export type LatestHistoryIdOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "latestId_ASC"
  | "latestId_DESC"
  | "reference_ASC"
  | "reference_DESC";

export type PracticalTestStatus = "NEEDSCONFIRMING" | "CONFIRMED" | "CHANGED";

export type PracticalTestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "gmailId_ASC"
  | "gmailId_DESC"
  | "checkTelephone_ASC"
  | "checkTelephone_DESC"
  | "studentName_ASC"
  | "studentName_DESC"
  | "location_ASC"
  | "location_DESC"
  | "testDate_ASC"
  | "testDate_DESC"
  | "lastChangeDate_ASC"
  | "lastChangeDate_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "emailContent_ASC"
  | "emailContent_DESC"
  | "isConfirmed_ASC"
  | "isConfirmed_DESC"
  | "status_ASC"
  | "status_DESC";

export type ProxyOrderByInput =
  | "lastUsedAt_ASC"
  | "lastUsedAt_DESC"
  | "proxy_ASC"
  | "proxy_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "type_ASC"
  | "type_DESC"
  | "stopUseUntil_ASC"
  | "stopUseUntil_DESC"
  | "lastUsedBy_ASC"
  | "lastUsedBy_DESC"
  | "taken_ASC"
  | "taken_DESC"
  | "blackListed_ASC"
  | "blackListed_DESC"
  | "blockCount_ASC"
  | "blockCount_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "zenId_ASC"
  | "zenId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "email_ASC"
  | "email_DESC";

export type TestCentreOrderByInput =
  | "centreId_ASC"
  | "centreId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "postcode_ASC"
  | "postcode_DESC"
  | "city_ASC"
  | "city_DESC";

export type UnavailabilityWindowOrderByInput =
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AgentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  zenId?: Int;
  email?: String;
}>;

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  zenId?: Int;
  zenId_not?: Int;
  zenId_in?: Int[] | Int;
  zenId_not_in?: Int[] | Int;
  zenId_lt?: Int;
  zenId_lte?: Int;
  zenId_gt?: Int;
  zenId_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  bookedAt?: DateTimeInput;
  bookedAt_not?: DateTimeInput;
  bookedAt_in?: DateTimeInput[] | DateTimeInput;
  bookedAt_not_in?: DateTimeInput[] | DateTimeInput;
  bookedAt_lt?: DateTimeInput;
  bookedAt_lte?: DateTimeInput;
  bookedAt_gt?: DateTimeInput;
  bookedAt_gte?: DateTimeInput;
  debt?: DebtWhereInput;
  agent?: AgentWhereInput;
  student?: StudentWhereInput;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  instructor_every?: InstructorWhereInput;
  instructor_some?: InstructorWhereInput;
  instructor_none?: InstructorWhereInput;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface DebtWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  booking?: BookingWhereInput;
  agent?: AgentWhereInput;
  instructor?: InstructorWhereInput;
  initialAmount?: Float;
  initialAmount_not?: Float;
  initialAmount_in?: Float[] | Float;
  initialAmount_not_in?: Float[] | Float;
  initialAmount_lt?: Float;
  initialAmount_lte?: Float;
  initialAmount_gt?: Float;
  initialAmount_gte?: Float;
  currentAmount?: Float;
  currentAmount_not?: Float;
  currentAmount_in?: Float[] | Float;
  currentAmount_not_in?: Float[] | Float;
  currentAmount_lt?: Float;
  currentAmount_lte?: Float;
  currentAmount_gt?: Float;
  currentAmount_gte?: Float;
  paidOff?: Boolean;
  paidOff_not?: Boolean;
  status?: DebtStatus;
  status_not?: DebtStatus;
  status_in?: DebtStatus[] | DebtStatus;
  status_not_in?: DebtStatus[] | DebtStatus;
  dueSince?: DateTimeInput;
  dueSince_not?: DateTimeInput;
  dueSince_in?: DateTimeInput[] | DateTimeInput;
  dueSince_not_in?: DateTimeInput[] | DateTimeInput;
  dueSince_lt?: DateTimeInput;
  dueSince_lte?: DateTimeInput;
  dueSince_gt?: DateTimeInput;
  dueSince_gte?: DateTimeInput;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  chases_every?: DebtChaseWhereInput;
  chases_some?: DebtChaseWhereInput;
  chases_none?: DebtChaseWhereInput;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  AND?: DebtWhereInput[] | DebtWhereInput;
  OR?: DebtWhereInput[] | DebtWhereInput;
  NOT?: DebtWhereInput[] | DebtWhereInput;
}

export interface AgentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  zenId?: Int;
  zenId_not?: Int;
  zenId_in?: Int[] | Int;
  zenId_not_in?: Int[] | Int;
  zenId_lt?: Int;
  zenId_lte?: Int;
  zenId_gt?: Int;
  zenId_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  booking_every?: BookingWhereInput;
  booking_some?: BookingWhereInput;
  booking_none?: BookingWhereInput;
  AND?: AgentWhereInput[] | AgentWhereInput;
  OR?: AgentWhereInput[] | AgentWhereInput;
  NOT?: AgentWhereInput[] | AgentWhereInput;
}

export interface InstructorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  zenId?: Int;
  zenId_not?: Int;
  zenId_in?: Int[] | Int;
  zenId_not_in?: Int[] | Int;
  zenId_lt?: Int;
  zenId_lte?: Int;
  zenId_gt?: Int;
  zenId_gte?: Int;
  debt_every?: DebtWhereInput;
  debt_some?: DebtWhereInput;
  debt_none?: DebtWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  joinedOn?: DateTimeInput;
  joinedOn_not?: DateTimeInput;
  joinedOn_in?: DateTimeInput[] | DateTimeInput;
  joinedOn_not_in?: DateTimeInput[] | DateTimeInput;
  joinedOn_lt?: DateTimeInput;
  joinedOn_lte?: DateTimeInput;
  joinedOn_gt?: DateTimeInput;
  joinedOn_gte?: DateTimeInput;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  postcode?: String;
  postcode_not?: String;
  postcode_in?: String[] | String;
  postcode_not_in?: String[] | String;
  postcode_lt?: String;
  postcode_lte?: String;
  postcode_gt?: String;
  postcode_gte?: String;
  postcode_contains?: String;
  postcode_not_contains?: String;
  postcode_starts_with?: String;
  postcode_not_starts_with?: String;
  postcode_ends_with?: String;
  postcode_not_ends_with?: String;
  AND?: InstructorWhereInput[] | InstructorWhereInput;
  OR?: InstructorWhereInput[] | InstructorWhereInput;
  NOT?: InstructorWhereInput[] | InstructorWhereInput;
}

export interface DebtChaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  debt?: DebtWhereInput;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  chasedOn?: DateTimeInput;
  chasedOn_not?: DateTimeInput;
  chasedOn_in?: DateTimeInput[] | DateTimeInput;
  chasedOn_not_in?: DateTimeInput[] | DateTimeInput;
  chasedOn_lt?: DateTimeInput;
  chasedOn_lte?: DateTimeInput;
  chasedOn_gt?: DateTimeInput;
  chasedOn_gte?: DateTimeInput;
  chasedBy?: AgentWhereInput;
  AND?: DebtChaseWhereInput[] | DebtChaseWhereInput;
  OR?: DebtChaseWhereInput[] | DebtChaseWhereInput;
  NOT?: DebtChaseWhereInput[] | DebtChaseWhereInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  paidOn?: DateTimeInput;
  paidOn_not?: DateTimeInput;
  paidOn_in?: DateTimeInput[] | DateTimeInput;
  paidOn_not_in?: DateTimeInput[] | DateTimeInput;
  paidOn_lt?: DateTimeInput;
  paidOn_lte?: DateTimeInput;
  paidOn_gt?: DateTimeInput;
  paidOn_gte?: DateTimeInput;
  debt?: DebtWhereInput;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  zenId?: Int;
  zenId_not?: Int;
  zenId_in?: Int[] | Int;
  zenId_not_in?: Int[] | Int;
  zenId_lt?: Int;
  zenId_lte?: Int;
  zenId_gt?: Int;
  zenId_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  zenId?: Int;
}>;

export type DebtWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DebtChaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FastTrackTestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  drivinglicense?: String;
  applicationRef?: String;
}>;

export interface FastTrackTestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  studentName?: String;
  studentName_not?: String;
  studentName_in?: String[] | String;
  studentName_not_in?: String[] | String;
  studentName_lt?: String;
  studentName_lte?: String;
  studentName_gt?: String;
  studentName_gte?: String;
  studentName_contains?: String;
  studentName_not_contains?: String;
  studentName_starts_with?: String;
  studentName_not_starts_with?: String;
  studentName_ends_with?: String;
  studentName_not_ends_with?: String;
  area?: String;
  area_not?: String;
  area_in?: String[] | String;
  area_not_in?: String[] | String;
  area_lt?: String;
  area_lte?: String;
  area_gt?: String;
  area_gte?: String;
  area_contains?: String;
  area_not_contains?: String;
  area_starts_with?: String;
  area_not_starts_with?: String;
  area_ends_with?: String;
  area_not_ends_with?: String;
  dealOwner?: String;
  dealOwner_not?: String;
  dealOwner_in?: String[] | String;
  dealOwner_not_in?: String[] | String;
  dealOwner_lt?: String;
  dealOwner_lte?: String;
  dealOwner_gt?: String;
  dealOwner_gte?: String;
  dealOwner_contains?: String;
  dealOwner_not_contains?: String;
  dealOwner_starts_with?: String;
  dealOwner_not_starts_with?: String;
  dealOwner_ends_with?: String;
  dealOwner_not_ends_with?: String;
  instructor?: String;
  instructor_not?: String;
  instructor_in?: String[] | String;
  instructor_not_in?: String[] | String;
  instructor_lt?: String;
  instructor_lte?: String;
  instructor_gt?: String;
  instructor_gte?: String;
  instructor_contains?: String;
  instructor_not_contains?: String;
  instructor_starts_with?: String;
  instructor_not_starts_with?: String;
  instructor_ends_with?: String;
  instructor_not_ends_with?: String;
  testCentrePrimary?: String;
  testCentrePrimary_not?: String;
  testCentrePrimary_in?: String[] | String;
  testCentrePrimary_not_in?: String[] | String;
  testCentrePrimary_lt?: String;
  testCentrePrimary_lte?: String;
  testCentrePrimary_gt?: String;
  testCentrePrimary_gte?: String;
  testCentrePrimary_contains?: String;
  testCentrePrimary_not_contains?: String;
  testCentrePrimary_starts_with?: String;
  testCentrePrimary_not_starts_with?: String;
  testCentrePrimary_ends_with?: String;
  testCentrePrimary_not_ends_with?: String;
  testCentreSecondary?: String;
  testCentreSecondary_not?: String;
  testCentreSecondary_in?: String[] | String;
  testCentreSecondary_not_in?: String[] | String;
  testCentreSecondary_lt?: String;
  testCentreSecondary_lte?: String;
  testCentreSecondary_gt?: String;
  testCentreSecondary_gte?: String;
  testCentreSecondary_contains?: String;
  testCentreSecondary_not_contains?: String;
  testCentreSecondary_starts_with?: String;
  testCentreSecondary_not_starts_with?: String;
  testCentreSecondary_ends_with?: String;
  testCentreSecondary_not_ends_with?: String;
  drivinglicense?: String;
  drivinglicense_not?: String;
  drivinglicense_in?: String[] | String;
  drivinglicense_not_in?: String[] | String;
  drivinglicense_lt?: String;
  drivinglicense_lte?: String;
  drivinglicense_gt?: String;
  drivinglicense_gte?: String;
  drivinglicense_contains?: String;
  drivinglicense_not_contains?: String;
  drivinglicense_starts_with?: String;
  drivinglicense_not_starts_with?: String;
  drivinglicense_ends_with?: String;
  drivinglicense_not_ends_with?: String;
  applicationRef?: String;
  applicationRef_not?: String;
  applicationRef_in?: String[] | String;
  applicationRef_not_in?: String[] | String;
  applicationRef_lt?: String;
  applicationRef_lte?: String;
  applicationRef_gt?: String;
  applicationRef_gte?: String;
  applicationRef_contains?: String;
  applicationRef_not_contains?: String;
  applicationRef_starts_with?: String;
  applicationRef_not_starts_with?: String;
  applicationRef_ends_with?: String;
  applicationRef_not_ends_with?: String;
  studentPostcode?: String;
  studentPostcode_not?: String;
  studentPostcode_in?: String[] | String;
  studentPostcode_not_in?: String[] | String;
  studentPostcode_lt?: String;
  studentPostcode_lte?: String;
  studentPostcode_gt?: String;
  studentPostcode_gte?: String;
  studentPostcode_contains?: String;
  studentPostcode_not_contains?: String;
  studentPostcode_starts_with?: String;
  studentPostcode_not_starts_with?: String;
  studentPostcode_ends_with?: String;
  studentPostcode_not_ends_with?: String;
  searchPostcode?: String;
  searchPostcode_not?: String;
  searchPostcode_in?: String[] | String;
  searchPostcode_not_in?: String[] | String;
  searchPostcode_lt?: String;
  searchPostcode_lte?: String;
  searchPostcode_gt?: String;
  searchPostcode_gte?: String;
  searchPostcode_contains?: String;
  searchPostcode_not_contains?: String;
  searchPostcode_starts_with?: String;
  searchPostcode_not_starts_with?: String;
  searchPostcode_ends_with?: String;
  searchPostcode_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  booked?: Boolean;
  booked_not?: Boolean;
  bookedDate?: DateTimeInput;
  bookedDate_not?: DateTimeInput;
  bookedDate_in?: DateTimeInput[] | DateTimeInput;
  bookedDate_not_in?: DateTimeInput[] | DateTimeInput;
  bookedDate_lt?: DateTimeInput;
  bookedDate_lte?: DateTimeInput;
  bookedDate_gt?: DateTimeInput;
  bookedDate_gte?: DateTimeInput;
  bookedCentre?: Int;
  bookedCentre_not?: Int;
  bookedCentre_in?: Int[] | Int;
  bookedCentre_not_in?: Int[] | Int;
  bookedCentre_lt?: Int;
  bookedCentre_lte?: Int;
  bookedCentre_gt?: Int;
  bookedCentre_gte?: Int;
  timeWhenBooked?: DateTimeInput;
  timeWhenBooked_not?: DateTimeInput;
  timeWhenBooked_in?: DateTimeInput[] | DateTimeInput;
  timeWhenBooked_not_in?: DateTimeInput[] | DateTimeInput;
  timeWhenBooked_lt?: DateTimeInput;
  timeWhenBooked_lte?: DateTimeInput;
  timeWhenBooked_gt?: DateTimeInput;
  timeWhenBooked_gte?: DateTimeInput;
  minimumDelay?: Int;
  minimumDelay_not?: Int;
  minimumDelay_in?: Int[] | Int;
  minimumDelay_not_in?: Int[] | Int;
  minimumDelay_lt?: Int;
  minimumDelay_lte?: Int;
  minimumDelay_gt?: Int;
  minimumDelay_gte?: Int;
  postcode?: String;
  postcode_not?: String;
  postcode_in?: String[] | String;
  postcode_not_in?: String[] | String;
  postcode_lt?: String;
  postcode_lte?: String;
  postcode_gt?: String;
  postcode_gte?: String;
  postcode_contains?: String;
  postcode_not_contains?: String;
  postcode_starts_with?: String;
  postcode_not_starts_with?: String;
  postcode_ends_with?: String;
  postcode_not_ends_with?: String;
  stopLooking?: Boolean;
  stopLooking_not?: Boolean;
  AND?: FastTrackTestWhereInput[] | FastTrackTestWhereInput;
  OR?: FastTrackTestWhereInput[] | FastTrackTestWhereInput;
  NOT?: FastTrackTestWhereInput[] | FastTrackTestWhereInput;
}

export type InstructorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  zenId?: Int;
}>;

export type LatestHistoryIdWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  latestId?: String;
  reference?: String;
}>;

export interface LatestHistoryIdWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  latestId?: String;
  latestId_not?: String;
  latestId_in?: String[] | String;
  latestId_not_in?: String[] | String;
  latestId_lt?: String;
  latestId_lte?: String;
  latestId_gt?: String;
  latestId_gte?: String;
  latestId_contains?: String;
  latestId_not_contains?: String;
  latestId_starts_with?: String;
  latestId_not_starts_with?: String;
  latestId_ends_with?: String;
  latestId_not_ends_with?: String;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  AND?: LatestHistoryIdWhereInput[] | LatestHistoryIdWhereInput;
  OR?: LatestHistoryIdWhereInput[] | LatestHistoryIdWhereInput;
  NOT?: LatestHistoryIdWhereInput[] | LatestHistoryIdWhereInput;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PracticalTestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  gmailId?: String;
  studentName?: String;
  reference?: String;
}>;

export interface PracticalTestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  gmailId?: String;
  gmailId_not?: String;
  gmailId_in?: String[] | String;
  gmailId_not_in?: String[] | String;
  gmailId_lt?: String;
  gmailId_lte?: String;
  gmailId_gt?: String;
  gmailId_gte?: String;
  gmailId_contains?: String;
  gmailId_not_contains?: String;
  gmailId_starts_with?: String;
  gmailId_not_starts_with?: String;
  gmailId_ends_with?: String;
  gmailId_not_ends_with?: String;
  checkTelephone?: String;
  checkTelephone_not?: String;
  checkTelephone_in?: String[] | String;
  checkTelephone_not_in?: String[] | String;
  checkTelephone_lt?: String;
  checkTelephone_lte?: String;
  checkTelephone_gt?: String;
  checkTelephone_gte?: String;
  checkTelephone_contains?: String;
  checkTelephone_not_contains?: String;
  checkTelephone_starts_with?: String;
  checkTelephone_not_starts_with?: String;
  checkTelephone_ends_with?: String;
  checkTelephone_not_ends_with?: String;
  studentName?: String;
  studentName_not?: String;
  studentName_in?: String[] | String;
  studentName_not_in?: String[] | String;
  studentName_lt?: String;
  studentName_lte?: String;
  studentName_gt?: String;
  studentName_gte?: String;
  studentName_contains?: String;
  studentName_not_contains?: String;
  studentName_starts_with?: String;
  studentName_not_starts_with?: String;
  studentName_ends_with?: String;
  studentName_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  testDate?: DateTimeInput;
  testDate_not?: DateTimeInput;
  testDate_in?: DateTimeInput[] | DateTimeInput;
  testDate_not_in?: DateTimeInput[] | DateTimeInput;
  testDate_lt?: DateTimeInput;
  testDate_lte?: DateTimeInput;
  testDate_gt?: DateTimeInput;
  testDate_gte?: DateTimeInput;
  lastChangeDate?: DateTimeInput;
  lastChangeDate_not?: DateTimeInput;
  lastChangeDate_in?: DateTimeInput[] | DateTimeInput;
  lastChangeDate_not_in?: DateTimeInput[] | DateTimeInput;
  lastChangeDate_lt?: DateTimeInput;
  lastChangeDate_lte?: DateTimeInput;
  lastChangeDate_gt?: DateTimeInput;
  lastChangeDate_gte?: DateTimeInput;
  reference?: String;
  reference_not?: String;
  reference_in?: String[] | String;
  reference_not_in?: String[] | String;
  reference_lt?: String;
  reference_lte?: String;
  reference_gt?: String;
  reference_gte?: String;
  reference_contains?: String;
  reference_not_contains?: String;
  reference_starts_with?: String;
  reference_not_starts_with?: String;
  reference_ends_with?: String;
  reference_not_ends_with?: String;
  booking?: BookingWhereInput;
  emailContent?: String;
  emailContent_not?: String;
  emailContent_in?: String[] | String;
  emailContent_not_in?: String[] | String;
  emailContent_lt?: String;
  emailContent_lte?: String;
  emailContent_gt?: String;
  emailContent_gte?: String;
  emailContent_contains?: String;
  emailContent_not_contains?: String;
  emailContent_starts_with?: String;
  emailContent_not_starts_with?: String;
  emailContent_ends_with?: String;
  emailContent_not_ends_with?: String;
  isConfirmed?: Boolean;
  isConfirmed_not?: Boolean;
  status?: PracticalTestStatus;
  status_not?: PracticalTestStatus;
  status_in?: PracticalTestStatus[] | PracticalTestStatus;
  status_not_in?: PracticalTestStatus[] | PracticalTestStatus;
  AND?: PracticalTestWhereInput[] | PracticalTestWhereInput;
  OR?: PracticalTestWhereInput[] | PracticalTestWhereInput;
  NOT?: PracticalTestWhereInput[] | PracticalTestWhereInput;
}

export type ProxyWhereUniqueInput = AtLeastOne<{
  ip: String;
}>;

export interface ProxyWhereInput {
  lastUsedAt?: DateTimeInput;
  lastUsedAt_not?: DateTimeInput;
  lastUsedAt_in?: DateTimeInput[] | DateTimeInput;
  lastUsedAt_not_in?: DateTimeInput[] | DateTimeInput;
  lastUsedAt_lt?: DateTimeInput;
  lastUsedAt_lte?: DateTimeInput;
  lastUsedAt_gt?: DateTimeInput;
  lastUsedAt_gte?: DateTimeInput;
  proxy?: String;
  proxy_not?: String;
  proxy_in?: String[] | String;
  proxy_not_in?: String[] | String;
  proxy_lt?: String;
  proxy_lte?: String;
  proxy_gt?: String;
  proxy_gte?: String;
  proxy_contains?: String;
  proxy_not_contains?: String;
  proxy_starts_with?: String;
  proxy_not_starts_with?: String;
  proxy_ends_with?: String;
  proxy_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  ip?: String;
  ip_not?: String;
  ip_in?: String[] | String;
  ip_not_in?: String[] | String;
  ip_lt?: String;
  ip_lte?: String;
  ip_gt?: String;
  ip_gte?: String;
  ip_contains?: String;
  ip_not_contains?: String;
  ip_starts_with?: String;
  ip_not_starts_with?: String;
  ip_ends_with?: String;
  ip_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  stopUseUntil?: DateTimeInput;
  stopUseUntil_not?: DateTimeInput;
  stopUseUntil_in?: DateTimeInput[] | DateTimeInput;
  stopUseUntil_not_in?: DateTimeInput[] | DateTimeInput;
  stopUseUntil_lt?: DateTimeInput;
  stopUseUntil_lte?: DateTimeInput;
  stopUseUntil_gt?: DateTimeInput;
  stopUseUntil_gte?: DateTimeInput;
  lastUsedBy?: String;
  lastUsedBy_not?: String;
  lastUsedBy_in?: String[] | String;
  lastUsedBy_not_in?: String[] | String;
  lastUsedBy_lt?: String;
  lastUsedBy_lte?: String;
  lastUsedBy_gt?: String;
  lastUsedBy_gte?: String;
  lastUsedBy_contains?: String;
  lastUsedBy_not_contains?: String;
  lastUsedBy_starts_with?: String;
  lastUsedBy_not_starts_with?: String;
  lastUsedBy_ends_with?: String;
  lastUsedBy_not_ends_with?: String;
  taken?: Boolean;
  taken_not?: Boolean;
  blackListed?: Boolean;
  blackListed_not?: Boolean;
  blockCount?: Int;
  blockCount_not?: Int;
  blockCount_in?: Int[] | Int;
  blockCount_not_in?: Int[] | Int;
  blockCount_lt?: Int;
  blockCount_lte?: Int;
  blockCount_gt?: Int;
  blockCount_gte?: Int;
  AND?: ProxyWhereInput[] | ProxyWhereInput;
  OR?: ProxyWhereInput[] | ProxyWhereInput;
  NOT?: ProxyWhereInput[] | ProxyWhereInput;
}

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  zenId?: Int;
}>;

export type TestCentreWhereUniqueInput = AtLeastOne<{
  centreId: Int;
}>;

export interface TestCentreWhereInput {
  centreId?: Int;
  centreId_not?: Int;
  centreId_in?: Int[] | Int;
  centreId_not_in?: Int[] | Int;
  centreId_lt?: Int;
  centreId_lte?: Int;
  centreId_gt?: Int;
  centreId_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  postcode?: String;
  postcode_not?: String;
  postcode_in?: String[] | String;
  postcode_not_in?: String[] | String;
  postcode_lt?: String;
  postcode_lte?: String;
  postcode_gt?: String;
  postcode_gte?: String;
  postcode_contains?: String;
  postcode_not_contains?: String;
  postcode_starts_with?: String;
  postcode_not_starts_with?: String;
  postcode_ends_with?: String;
  postcode_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  AND?: TestCentreWhereInput[] | TestCentreWhereInput;
  OR?: TestCentreWhereInput[] | TestCentreWhereInput;
  NOT?: TestCentreWhereInput[] | TestCentreWhereInput;
}

export interface UnavailabilityWindowWhereInput {
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  reason?: String;
  reason_not?: String;
  reason_in?: String[] | String;
  reason_not_in?: String[] | String;
  reason_lt?: String;
  reason_lte?: String;
  reason_gt?: String;
  reason_gte?: String;
  reason_contains?: String;
  reason_not_contains?: String;
  reason_starts_with?: String;
  reason_not_starts_with?: String;
  reason_ends_with?: String;
  reason_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UnavailabilityWindowWhereInput[] | UnavailabilityWindowWhereInput;
  OR?: UnavailabilityWindowWhereInput[] | UnavailabilityWindowWhereInput;
  NOT?: UnavailabilityWindowWhereInput[] | UnavailabilityWindowWhereInput;
}

export interface AgentCreateInput {
  zenId?: Int;
  name: String;
  email?: String;
  booking?: BookingCreateManyWithoutAgentInput;
}

export interface BookingCreateManyWithoutAgentInput {
  create?: BookingCreateWithoutAgentInput[] | BookingCreateWithoutAgentInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface BookingCreateWithoutAgentInput {
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeInput;
  debt?: DebtCreateOneWithoutBookingInput;
  student?: StudentCreateOneWithoutBookingsInput;
  amount: Float;
  instructor?: InstructorCreateManyWithoutBookingsInput;
}

export interface DebtCreateOneWithoutBookingInput {
  create?: DebtCreateWithoutBookingInput;
  connect?: DebtWhereUniqueInput;
}

export interface DebtCreateWithoutBookingInput {
  agent?: AgentCreateOneInput;
  instructor: InstructorCreateOneWithoutDebtInput;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseCreateManyWithoutDebtInput;
  payments?: PaymentCreateManyWithoutDebtInput;
}

export interface AgentCreateOneInput {
  create?: AgentCreateInput;
  connect?: AgentWhereUniqueInput;
}

export interface InstructorCreateOneWithoutDebtInput {
  create?: InstructorCreateWithoutDebtInput;
  connect?: InstructorWhereUniqueInput;
}

export interface InstructorCreateWithoutDebtInput {
  bookings?: BookingCreateManyWithoutInstructorInput;
  zenId?: Int;
  name: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface BookingCreateManyWithoutInstructorInput {
  create?:
    | BookingCreateWithoutInstructorInput[]
    | BookingCreateWithoutInstructorInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface BookingCreateWithoutInstructorInput {
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeInput;
  debt?: DebtCreateOneWithoutBookingInput;
  agent: AgentCreateOneWithoutBookingInput;
  student?: StudentCreateOneWithoutBookingsInput;
  amount: Float;
}

export interface AgentCreateOneWithoutBookingInput {
  create?: AgentCreateWithoutBookingInput;
  connect?: AgentWhereUniqueInput;
}

export interface AgentCreateWithoutBookingInput {
  zenId?: Int;
  name: String;
  email?: String;
}

export interface StudentCreateOneWithoutBookingsInput {
  create?: StudentCreateWithoutBookingsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutBookingsInput {
  zenId?: Int;
  name: String;
  phone?: String;
  email?: String;
}

export interface DebtChaseCreateManyWithoutDebtInput {
  create?: DebtChaseCreateWithoutDebtInput[] | DebtChaseCreateWithoutDebtInput;
  connect?: DebtChaseWhereUniqueInput[] | DebtChaseWhereUniqueInput;
}

export interface DebtChaseCreateWithoutDebtInput {
  notes?: String;
  chasedOn: DateTimeInput;
  chasedBy?: AgentCreateOneInput;
}

export interface PaymentCreateManyWithoutDebtInput {
  create?: PaymentCreateWithoutDebtInput[] | PaymentCreateWithoutDebtInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface PaymentCreateWithoutDebtInput {
  paidOn?: DateTimeInput;
  amount: Float;
  notes?: String;
}

export interface InstructorCreateManyWithoutBookingsInput {
  create?:
    | InstructorCreateWithoutBookingsInput[]
    | InstructorCreateWithoutBookingsInput;
  connect?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
}

export interface InstructorCreateWithoutBookingsInput {
  zenId?: Int;
  debt?: DebtCreateManyWithoutInstructorInput;
  name: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface DebtCreateManyWithoutInstructorInput {
  create?:
    | DebtCreateWithoutInstructorInput[]
    | DebtCreateWithoutInstructorInput;
  connect?: DebtWhereUniqueInput[] | DebtWhereUniqueInput;
}

export interface DebtCreateWithoutInstructorInput {
  booking?: BookingCreateOneWithoutDebtInput;
  agent?: AgentCreateOneInput;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseCreateManyWithoutDebtInput;
  payments?: PaymentCreateManyWithoutDebtInput;
}

export interface BookingCreateOneWithoutDebtInput {
  create?: BookingCreateWithoutDebtInput;
  connect?: BookingWhereUniqueInput;
}

export interface BookingCreateWithoutDebtInput {
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeInput;
  agent: AgentCreateOneWithoutBookingInput;
  student?: StudentCreateOneWithoutBookingsInput;
  amount: Float;
  instructor?: InstructorCreateManyWithoutBookingsInput;
}

export interface AgentUpdateInput {
  zenId?: Int;
  name?: String;
  email?: String;
  booking?: BookingUpdateManyWithoutAgentInput;
}

export interface BookingUpdateManyWithoutAgentInput {
  create?: BookingCreateWithoutAgentInput[] | BookingCreateWithoutAgentInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutAgentInput[]
    | BookingUpdateWithWhereUniqueWithoutAgentInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutAgentInput[]
    | BookingUpsertWithWhereUniqueWithoutAgentInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface BookingUpdateWithWhereUniqueWithoutAgentInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutAgentDataInput;
}

export interface BookingUpdateWithoutAgentDataInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  debt?: DebtUpdateOneWithoutBookingInput;
  student?: StudentUpdateOneWithoutBookingsInput;
  amount?: Float;
  instructor?: InstructorUpdateManyWithoutBookingsInput;
}

export interface DebtUpdateOneWithoutBookingInput {
  create?: DebtCreateWithoutBookingInput;
  update?: DebtUpdateWithoutBookingDataInput;
  upsert?: DebtUpsertWithoutBookingInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DebtWhereUniqueInput;
}

export interface DebtUpdateWithoutBookingDataInput {
  agent?: AgentUpdateOneInput;
  instructor?: InstructorUpdateOneRequiredWithoutDebtInput;
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseUpdateManyWithoutDebtInput;
  payments?: PaymentUpdateManyWithoutDebtInput;
}

export interface AgentUpdateOneInput {
  create?: AgentCreateInput;
  update?: AgentUpdateDataInput;
  upsert?: AgentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AgentWhereUniqueInput;
}

export interface AgentUpdateDataInput {
  zenId?: Int;
  name?: String;
  email?: String;
  booking?: BookingUpdateManyWithoutAgentInput;
}

export interface AgentUpsertNestedInput {
  update: AgentUpdateDataInput;
  create: AgentCreateInput;
}

export interface InstructorUpdateOneRequiredWithoutDebtInput {
  create?: InstructorCreateWithoutDebtInput;
  update?: InstructorUpdateWithoutDebtDataInput;
  upsert?: InstructorUpsertWithoutDebtInput;
  connect?: InstructorWhereUniqueInput;
}

export interface InstructorUpdateWithoutDebtDataInput {
  bookings?: BookingUpdateManyWithoutInstructorInput;
  zenId?: Int;
  name?: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface BookingUpdateManyWithoutInstructorInput {
  create?:
    | BookingCreateWithoutInstructorInput[]
    | BookingCreateWithoutInstructorInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutInstructorInput[]
    | BookingUpdateWithWhereUniqueWithoutInstructorInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutInstructorInput[]
    | BookingUpsertWithWhereUniqueWithoutInstructorInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface BookingUpdateWithWhereUniqueWithoutInstructorInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutInstructorDataInput;
}

export interface BookingUpdateWithoutInstructorDataInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  debt?: DebtUpdateOneWithoutBookingInput;
  agent?: AgentUpdateOneRequiredWithoutBookingInput;
  student?: StudentUpdateOneWithoutBookingsInput;
  amount?: Float;
}

export interface AgentUpdateOneRequiredWithoutBookingInput {
  create?: AgentCreateWithoutBookingInput;
  update?: AgentUpdateWithoutBookingDataInput;
  upsert?: AgentUpsertWithoutBookingInput;
  connect?: AgentWhereUniqueInput;
}

export interface AgentUpdateWithoutBookingDataInput {
  zenId?: Int;
  name?: String;
  email?: String;
}

export interface AgentUpsertWithoutBookingInput {
  update: AgentUpdateWithoutBookingDataInput;
  create: AgentCreateWithoutBookingInput;
}

export interface StudentUpdateOneWithoutBookingsInput {
  create?: StudentCreateWithoutBookingsInput;
  update?: StudentUpdateWithoutBookingsDataInput;
  upsert?: StudentUpsertWithoutBookingsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutBookingsDataInput {
  zenId?: Int;
  name?: String;
  phone?: String;
  email?: String;
}

export interface StudentUpsertWithoutBookingsInput {
  update: StudentUpdateWithoutBookingsDataInput;
  create: StudentCreateWithoutBookingsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutInstructorInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutInstructorDataInput;
  create: BookingCreateWithoutInstructorInput;
}

export interface BookingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  zenId?: Int;
  zenId_not?: Int;
  zenId_in?: Int[] | Int;
  zenId_not_in?: Int[] | Int;
  zenId_lt?: Int;
  zenId_lte?: Int;
  zenId_gt?: Int;
  zenId_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  bookedAt?: DateTimeInput;
  bookedAt_not?: DateTimeInput;
  bookedAt_in?: DateTimeInput[] | DateTimeInput;
  bookedAt_not_in?: DateTimeInput[] | DateTimeInput;
  bookedAt_lt?: DateTimeInput;
  bookedAt_lte?: DateTimeInput;
  bookedAt_gt?: DateTimeInput;
  bookedAt_gte?: DateTimeInput;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  AND?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  OR?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  NOT?: BookingScalarWhereInput[] | BookingScalarWhereInput;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface BookingUpdateManyDataInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  amount?: Float;
}

export interface InstructorUpsertWithoutDebtInput {
  update: InstructorUpdateWithoutDebtDataInput;
  create: InstructorCreateWithoutDebtInput;
}

export interface DebtChaseUpdateManyWithoutDebtInput {
  create?: DebtChaseCreateWithoutDebtInput[] | DebtChaseCreateWithoutDebtInput;
  delete?: DebtChaseWhereUniqueInput[] | DebtChaseWhereUniqueInput;
  connect?: DebtChaseWhereUniqueInput[] | DebtChaseWhereUniqueInput;
  set?: DebtChaseWhereUniqueInput[] | DebtChaseWhereUniqueInput;
  disconnect?: DebtChaseWhereUniqueInput[] | DebtChaseWhereUniqueInput;
  update?:
    | DebtChaseUpdateWithWhereUniqueWithoutDebtInput[]
    | DebtChaseUpdateWithWhereUniqueWithoutDebtInput;
  upsert?:
    | DebtChaseUpsertWithWhereUniqueWithoutDebtInput[]
    | DebtChaseUpsertWithWhereUniqueWithoutDebtInput;
  deleteMany?: DebtChaseScalarWhereInput[] | DebtChaseScalarWhereInput;
  updateMany?:
    | DebtChaseUpdateManyWithWhereNestedInput[]
    | DebtChaseUpdateManyWithWhereNestedInput;
}

export interface DebtChaseUpdateWithWhereUniqueWithoutDebtInput {
  where: DebtChaseWhereUniqueInput;
  data: DebtChaseUpdateWithoutDebtDataInput;
}

export interface DebtChaseUpdateWithoutDebtDataInput {
  notes?: String;
  chasedOn?: DateTimeInput;
  chasedBy?: AgentUpdateOneInput;
}

export interface DebtChaseUpsertWithWhereUniqueWithoutDebtInput {
  where: DebtChaseWhereUniqueInput;
  update: DebtChaseUpdateWithoutDebtDataInput;
  create: DebtChaseCreateWithoutDebtInput;
}

export interface DebtChaseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  chasedOn?: DateTimeInput;
  chasedOn_not?: DateTimeInput;
  chasedOn_in?: DateTimeInput[] | DateTimeInput;
  chasedOn_not_in?: DateTimeInput[] | DateTimeInput;
  chasedOn_lt?: DateTimeInput;
  chasedOn_lte?: DateTimeInput;
  chasedOn_gt?: DateTimeInput;
  chasedOn_gte?: DateTimeInput;
  AND?: DebtChaseScalarWhereInput[] | DebtChaseScalarWhereInput;
  OR?: DebtChaseScalarWhereInput[] | DebtChaseScalarWhereInput;
  NOT?: DebtChaseScalarWhereInput[] | DebtChaseScalarWhereInput;
}

export interface DebtChaseUpdateManyWithWhereNestedInput {
  where: DebtChaseScalarWhereInput;
  data: DebtChaseUpdateManyDataInput;
}

export interface DebtChaseUpdateManyDataInput {
  notes?: String;
  chasedOn?: DateTimeInput;
}

export interface PaymentUpdateManyWithoutDebtInput {
  create?: PaymentCreateWithoutDebtInput[] | PaymentCreateWithoutDebtInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  set?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutDebtInput[]
    | PaymentUpdateWithWhereUniqueWithoutDebtInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutDebtInput[]
    | PaymentUpsertWithWhereUniqueWithoutDebtInput;
  deleteMany?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  updateMany?:
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput;
}

export interface PaymentUpdateWithWhereUniqueWithoutDebtInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutDebtDataInput;
}

export interface PaymentUpdateWithoutDebtDataInput {
  paidOn?: DateTimeInput;
  amount?: Float;
  notes?: String;
}

export interface PaymentUpsertWithWhereUniqueWithoutDebtInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutDebtDataInput;
  create: PaymentCreateWithoutDebtInput;
}

export interface PaymentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  paidOn?: DateTimeInput;
  paidOn_not?: DateTimeInput;
  paidOn_in?: DateTimeInput[] | DateTimeInput;
  paidOn_not_in?: DateTimeInput[] | DateTimeInput;
  paidOn_lt?: DateTimeInput;
  paidOn_lte?: DateTimeInput;
  paidOn_gt?: DateTimeInput;
  paidOn_gte?: DateTimeInput;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  AND?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  OR?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  NOT?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PaymentUpdateManyDataInput {
  paidOn?: DateTimeInput;
  amount?: Float;
  notes?: String;
}

export interface DebtUpsertWithoutBookingInput {
  update: DebtUpdateWithoutBookingDataInput;
  create: DebtCreateWithoutBookingInput;
}

export interface InstructorUpdateManyWithoutBookingsInput {
  create?:
    | InstructorCreateWithoutBookingsInput[]
    | InstructorCreateWithoutBookingsInput;
  delete?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  connect?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  set?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  disconnect?: InstructorWhereUniqueInput[] | InstructorWhereUniqueInput;
  update?:
    | InstructorUpdateWithWhereUniqueWithoutBookingsInput[]
    | InstructorUpdateWithWhereUniqueWithoutBookingsInput;
  upsert?:
    | InstructorUpsertWithWhereUniqueWithoutBookingsInput[]
    | InstructorUpsertWithWhereUniqueWithoutBookingsInput;
  deleteMany?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
  updateMany?:
    | InstructorUpdateManyWithWhereNestedInput[]
    | InstructorUpdateManyWithWhereNestedInput;
}

export interface InstructorUpdateWithWhereUniqueWithoutBookingsInput {
  where: InstructorWhereUniqueInput;
  data: InstructorUpdateWithoutBookingsDataInput;
}

export interface InstructorUpdateWithoutBookingsDataInput {
  zenId?: Int;
  debt?: DebtUpdateManyWithoutInstructorInput;
  name?: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface DebtUpdateManyWithoutInstructorInput {
  create?:
    | DebtCreateWithoutInstructorInput[]
    | DebtCreateWithoutInstructorInput;
  delete?: DebtWhereUniqueInput[] | DebtWhereUniqueInput;
  connect?: DebtWhereUniqueInput[] | DebtWhereUniqueInput;
  set?: DebtWhereUniqueInput[] | DebtWhereUniqueInput;
  disconnect?: DebtWhereUniqueInput[] | DebtWhereUniqueInput;
  update?:
    | DebtUpdateWithWhereUniqueWithoutInstructorInput[]
    | DebtUpdateWithWhereUniqueWithoutInstructorInput;
  upsert?:
    | DebtUpsertWithWhereUniqueWithoutInstructorInput[]
    | DebtUpsertWithWhereUniqueWithoutInstructorInput;
  deleteMany?: DebtScalarWhereInput[] | DebtScalarWhereInput;
  updateMany?:
    | DebtUpdateManyWithWhereNestedInput[]
    | DebtUpdateManyWithWhereNestedInput;
}

export interface DebtUpdateWithWhereUniqueWithoutInstructorInput {
  where: DebtWhereUniqueInput;
  data: DebtUpdateWithoutInstructorDataInput;
}

export interface DebtUpdateWithoutInstructorDataInput {
  booking?: BookingUpdateOneWithoutDebtInput;
  agent?: AgentUpdateOneInput;
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseUpdateManyWithoutDebtInput;
  payments?: PaymentUpdateManyWithoutDebtInput;
}

export interface BookingUpdateOneWithoutDebtInput {
  create?: BookingCreateWithoutDebtInput;
  update?: BookingUpdateWithoutDebtDataInput;
  upsert?: BookingUpsertWithoutDebtInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BookingWhereUniqueInput;
}

export interface BookingUpdateWithoutDebtDataInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  agent?: AgentUpdateOneRequiredWithoutBookingInput;
  student?: StudentUpdateOneWithoutBookingsInput;
  amount?: Float;
  instructor?: InstructorUpdateManyWithoutBookingsInput;
}

export interface BookingUpsertWithoutDebtInput {
  update: BookingUpdateWithoutDebtDataInput;
  create: BookingCreateWithoutDebtInput;
}

export interface DebtUpsertWithWhereUniqueWithoutInstructorInput {
  where: DebtWhereUniqueInput;
  update: DebtUpdateWithoutInstructorDataInput;
  create: DebtCreateWithoutInstructorInput;
}

export interface DebtScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  initialAmount?: Float;
  initialAmount_not?: Float;
  initialAmount_in?: Float[] | Float;
  initialAmount_not_in?: Float[] | Float;
  initialAmount_lt?: Float;
  initialAmount_lte?: Float;
  initialAmount_gt?: Float;
  initialAmount_gte?: Float;
  currentAmount?: Float;
  currentAmount_not?: Float;
  currentAmount_in?: Float[] | Float;
  currentAmount_not_in?: Float[] | Float;
  currentAmount_lt?: Float;
  currentAmount_lte?: Float;
  currentAmount_gt?: Float;
  currentAmount_gte?: Float;
  paidOff?: Boolean;
  paidOff_not?: Boolean;
  status?: DebtStatus;
  status_not?: DebtStatus;
  status_in?: DebtStatus[] | DebtStatus;
  status_not_in?: DebtStatus[] | DebtStatus;
  dueSince?: DateTimeInput;
  dueSince_not?: DateTimeInput;
  dueSince_in?: DateTimeInput[] | DateTimeInput;
  dueSince_not_in?: DateTimeInput[] | DateTimeInput;
  dueSince_lt?: DateTimeInput;
  dueSince_lte?: DateTimeInput;
  dueSince_gt?: DateTimeInput;
  dueSince_gte?: DateTimeInput;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  AND?: DebtScalarWhereInput[] | DebtScalarWhereInput;
  OR?: DebtScalarWhereInput[] | DebtScalarWhereInput;
  NOT?: DebtScalarWhereInput[] | DebtScalarWhereInput;
}

export interface DebtUpdateManyWithWhereNestedInput {
  where: DebtScalarWhereInput;
  data: DebtUpdateManyDataInput;
}

export interface DebtUpdateManyDataInput {
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
}

export interface InstructorUpsertWithWhereUniqueWithoutBookingsInput {
  where: InstructorWhereUniqueInput;
  update: InstructorUpdateWithoutBookingsDataInput;
  create: InstructorCreateWithoutBookingsInput;
}

export interface InstructorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  zenId?: Int;
  zenId_not?: Int;
  zenId_in?: Int[] | Int;
  zenId_not_in?: Int[] | Int;
  zenId_lt?: Int;
  zenId_lte?: Int;
  zenId_gt?: Int;
  zenId_gte?: Int;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  joinedOn?: DateTimeInput;
  joinedOn_not?: DateTimeInput;
  joinedOn_in?: DateTimeInput[] | DateTimeInput;
  joinedOn_not_in?: DateTimeInput[] | DateTimeInput;
  joinedOn_lt?: DateTimeInput;
  joinedOn_lte?: DateTimeInput;
  joinedOn_gt?: DateTimeInput;
  joinedOn_gte?: DateTimeInput;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  postcode?: String;
  postcode_not?: String;
  postcode_in?: String[] | String;
  postcode_not_in?: String[] | String;
  postcode_lt?: String;
  postcode_lte?: String;
  postcode_gt?: String;
  postcode_gte?: String;
  postcode_contains?: String;
  postcode_not_contains?: String;
  postcode_starts_with?: String;
  postcode_not_starts_with?: String;
  postcode_ends_with?: String;
  postcode_not_ends_with?: String;
  AND?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
  OR?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
  NOT?: InstructorScalarWhereInput[] | InstructorScalarWhereInput;
}

export interface InstructorUpdateManyWithWhereNestedInput {
  where: InstructorScalarWhereInput;
  data: InstructorUpdateManyDataInput;
}

export interface InstructorUpdateManyDataInput {
  zenId?: Int;
  name?: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface BookingUpsertWithWhereUniqueWithoutAgentInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutAgentDataInput;
  create: BookingCreateWithoutAgentInput;
}

export interface AgentUpdateManyMutationInput {
  zenId?: Int;
  name?: String;
  email?: String;
}

export interface BookingCreateInput {
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeInput;
  debt?: DebtCreateOneWithoutBookingInput;
  agent: AgentCreateOneWithoutBookingInput;
  student?: StudentCreateOneWithoutBookingsInput;
  amount: Float;
  instructor?: InstructorCreateManyWithoutBookingsInput;
}

export interface BookingUpdateInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  debt?: DebtUpdateOneWithoutBookingInput;
  agent?: AgentUpdateOneRequiredWithoutBookingInput;
  student?: StudentUpdateOneWithoutBookingsInput;
  amount?: Float;
  instructor?: InstructorUpdateManyWithoutBookingsInput;
}

export interface BookingUpdateManyMutationInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  amount?: Float;
}

export interface DebtCreateInput {
  booking?: BookingCreateOneWithoutDebtInput;
  agent?: AgentCreateOneInput;
  instructor: InstructorCreateOneWithoutDebtInput;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseCreateManyWithoutDebtInput;
  payments?: PaymentCreateManyWithoutDebtInput;
}

export interface DebtUpdateInput {
  booking?: BookingUpdateOneWithoutDebtInput;
  agent?: AgentUpdateOneInput;
  instructor?: InstructorUpdateOneRequiredWithoutDebtInput;
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseUpdateManyWithoutDebtInput;
  payments?: PaymentUpdateManyWithoutDebtInput;
}

export interface DebtUpdateManyMutationInput {
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
}

export interface DebtChaseCreateInput {
  debt: DebtCreateOneWithoutChasesInput;
  notes?: String;
  chasedOn: DateTimeInput;
  chasedBy?: AgentCreateOneInput;
}

export interface DebtCreateOneWithoutChasesInput {
  create?: DebtCreateWithoutChasesInput;
  connect?: DebtWhereUniqueInput;
}

export interface DebtCreateWithoutChasesInput {
  booking?: BookingCreateOneWithoutDebtInput;
  agent?: AgentCreateOneInput;
  instructor: InstructorCreateOneWithoutDebtInput;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  payments?: PaymentCreateManyWithoutDebtInput;
}

export interface DebtChaseUpdateInput {
  debt?: DebtUpdateOneRequiredWithoutChasesInput;
  notes?: String;
  chasedOn?: DateTimeInput;
  chasedBy?: AgentUpdateOneInput;
}

export interface DebtUpdateOneRequiredWithoutChasesInput {
  create?: DebtCreateWithoutChasesInput;
  update?: DebtUpdateWithoutChasesDataInput;
  upsert?: DebtUpsertWithoutChasesInput;
  connect?: DebtWhereUniqueInput;
}

export interface DebtUpdateWithoutChasesDataInput {
  booking?: BookingUpdateOneWithoutDebtInput;
  agent?: AgentUpdateOneInput;
  instructor?: InstructorUpdateOneRequiredWithoutDebtInput;
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  payments?: PaymentUpdateManyWithoutDebtInput;
}

export interface DebtUpsertWithoutChasesInput {
  update: DebtUpdateWithoutChasesDataInput;
  create: DebtCreateWithoutChasesInput;
}

export interface DebtChaseUpdateManyMutationInput {
  notes?: String;
  chasedOn?: DateTimeInput;
}

export interface FastTrackTestCreateInput {
  studentName?: String;
  area?: String;
  dealOwner?: String;
  instructor?: String;
  testCentrePrimary?: String;
  testCentreSecondary?: String;
  drivinglicense: String;
  applicationRef: String;
  studentPostcode?: String;
  searchPostcode?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  hoursToAvoid?: FastTrackTestCreatehoursToAvoidInput;
  daysToAvoid?: FastTrackTestCreatedaysToAvoidInput;
  datesToAvoid?: FastTrackTestCreatedatesToAvoidInput;
  testCentres?: FastTrackTestCreatetestCentresInput;
  specificDays?: FastTrackTestCreatespecificDaysInput;
  specificDates?: FastTrackTestCreatespecificDatesInput;
  specificHours?: FastTrackTestCreatespecificHoursInput;
  booked?: Boolean;
  bookedDate?: DateTimeInput;
  bookedCentre?: Int;
  timeWhenBooked?: DateTimeInput;
  minimumDelay?: Int;
  postcode?: String;
  stopLooking?: Boolean;
}

export interface FastTrackTestCreatehoursToAvoidInput {
  set?: Int[] | Int;
}

export interface FastTrackTestCreatedaysToAvoidInput {
  set?: Int[] | Int;
}

export interface FastTrackTestCreatedatesToAvoidInput {
  set?: Int[] | Int;
}

export interface FastTrackTestCreatetestCentresInput {
  set?: Int[] | Int;
}

export interface FastTrackTestCreatespecificDaysInput {
  set?: Int[] | Int;
}

export interface FastTrackTestCreatespecificDatesInput {
  set?: Int[] | Int;
}

export interface FastTrackTestCreatespecificHoursInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdateInput {
  studentName?: String;
  area?: String;
  dealOwner?: String;
  instructor?: String;
  testCentrePrimary?: String;
  testCentreSecondary?: String;
  drivinglicense?: String;
  applicationRef?: String;
  studentPostcode?: String;
  searchPostcode?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  hoursToAvoid?: FastTrackTestUpdatehoursToAvoidInput;
  daysToAvoid?: FastTrackTestUpdatedaysToAvoidInput;
  datesToAvoid?: FastTrackTestUpdatedatesToAvoidInput;
  testCentres?: FastTrackTestUpdatetestCentresInput;
  specificDays?: FastTrackTestUpdatespecificDaysInput;
  specificDates?: FastTrackTestUpdatespecificDatesInput;
  specificHours?: FastTrackTestUpdatespecificHoursInput;
  booked?: Boolean;
  bookedDate?: DateTimeInput;
  bookedCentre?: Int;
  timeWhenBooked?: DateTimeInput;
  minimumDelay?: Int;
  postcode?: String;
  stopLooking?: Boolean;
}

export interface FastTrackTestUpdatehoursToAvoidInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdatedaysToAvoidInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdatedatesToAvoidInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdatetestCentresInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdatespecificDaysInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdatespecificDatesInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdatespecificHoursInput {
  set?: Int[] | Int;
}

export interface FastTrackTestUpdateManyMutationInput {
  studentName?: String;
  area?: String;
  dealOwner?: String;
  instructor?: String;
  testCentrePrimary?: String;
  testCentreSecondary?: String;
  drivinglicense?: String;
  applicationRef?: String;
  studentPostcode?: String;
  searchPostcode?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  hoursToAvoid?: FastTrackTestUpdatehoursToAvoidInput;
  daysToAvoid?: FastTrackTestUpdatedaysToAvoidInput;
  datesToAvoid?: FastTrackTestUpdatedatesToAvoidInput;
  testCentres?: FastTrackTestUpdatetestCentresInput;
  specificDays?: FastTrackTestUpdatespecificDaysInput;
  specificDates?: FastTrackTestUpdatespecificDatesInput;
  specificHours?: FastTrackTestUpdatespecificHoursInput;
  booked?: Boolean;
  bookedDate?: DateTimeInput;
  bookedCentre?: Int;
  timeWhenBooked?: DateTimeInput;
  minimumDelay?: Int;
  postcode?: String;
  stopLooking?: Boolean;
}

export interface InstructorCreateInput {
  bookings?: BookingCreateManyWithoutInstructorInput;
  zenId?: Int;
  debt?: DebtCreateManyWithoutInstructorInput;
  name: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface InstructorUpdateInput {
  bookings?: BookingUpdateManyWithoutInstructorInput;
  zenId?: Int;
  debt?: DebtUpdateManyWithoutInstructorInput;
  name?: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface InstructorUpdateManyMutationInput {
  zenId?: Int;
  name?: String;
  joinedOn?: DateTimeInput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface LatestHistoryIdCreateInput {
  latestId?: String;
  reference?: String;
}

export interface LatestHistoryIdUpdateInput {
  latestId?: String;
  reference?: String;
}

export interface LatestHistoryIdUpdateManyMutationInput {
  latestId?: String;
  reference?: String;
}

export interface PaymentCreateInput {
  paidOn?: DateTimeInput;
  debt: DebtCreateOneWithoutPaymentsInput;
  amount: Float;
  notes?: String;
}

export interface DebtCreateOneWithoutPaymentsInput {
  create?: DebtCreateWithoutPaymentsInput;
  connect?: DebtWhereUniqueInput;
}

export interface DebtCreateWithoutPaymentsInput {
  booking?: BookingCreateOneWithoutDebtInput;
  agent?: AgentCreateOneInput;
  instructor: InstructorCreateOneWithoutDebtInput;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseCreateManyWithoutDebtInput;
}

export interface PaymentUpdateInput {
  paidOn?: DateTimeInput;
  debt?: DebtUpdateOneRequiredWithoutPaymentsInput;
  amount?: Float;
  notes?: String;
}

export interface DebtUpdateOneRequiredWithoutPaymentsInput {
  create?: DebtCreateWithoutPaymentsInput;
  update?: DebtUpdateWithoutPaymentsDataInput;
  upsert?: DebtUpsertWithoutPaymentsInput;
  connect?: DebtWhereUniqueInput;
}

export interface DebtUpdateWithoutPaymentsDataInput {
  booking?: BookingUpdateOneWithoutDebtInput;
  agent?: AgentUpdateOneInput;
  instructor?: InstructorUpdateOneRequiredWithoutDebtInput;
  initialAmount?: Float;
  currentAmount?: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeInput;
  notes?: String;
  chases?: DebtChaseUpdateManyWithoutDebtInput;
}

export interface DebtUpsertWithoutPaymentsInput {
  update: DebtUpdateWithoutPaymentsDataInput;
  create: DebtCreateWithoutPaymentsInput;
}

export interface PaymentUpdateManyMutationInput {
  paidOn?: DateTimeInput;
  amount?: Float;
  notes?: String;
}

export interface PracticalTestCreateInput {
  gmailId?: String;
  checkTelephone?: String;
  studentName?: String;
  location?: String;
  testDate?: DateTimeInput;
  lastChangeDate?: DateTimeInput;
  reference: String;
  booking?: BookingCreateOneInput;
  emailContent?: String;
  isConfirmed?: Boolean;
  status?: PracticalTestStatus;
}

export interface BookingCreateOneInput {
  create?: BookingCreateInput;
  connect?: BookingWhereUniqueInput;
}

export interface PracticalTestUpdateInput {
  gmailId?: String;
  checkTelephone?: String;
  studentName?: String;
  location?: String;
  testDate?: DateTimeInput;
  lastChangeDate?: DateTimeInput;
  reference?: String;
  booking?: BookingUpdateOneInput;
  emailContent?: String;
  isConfirmed?: Boolean;
  status?: PracticalTestStatus;
}

export interface BookingUpdateOneInput {
  create?: BookingCreateInput;
  update?: BookingUpdateDataInput;
  upsert?: BookingUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BookingWhereUniqueInput;
}

export interface BookingUpdateDataInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  debt?: DebtUpdateOneWithoutBookingInput;
  agent?: AgentUpdateOneRequiredWithoutBookingInput;
  student?: StudentUpdateOneWithoutBookingsInput;
  amount?: Float;
  instructor?: InstructorUpdateManyWithoutBookingsInput;
}

export interface BookingUpsertNestedInput {
  update: BookingUpdateDataInput;
  create: BookingCreateInput;
}

export interface PracticalTestUpdateManyMutationInput {
  gmailId?: String;
  checkTelephone?: String;
  studentName?: String;
  location?: String;
  testDate?: DateTimeInput;
  lastChangeDate?: DateTimeInput;
  reference?: String;
  emailContent?: String;
  isConfirmed?: Boolean;
  status?: PracticalTestStatus;
}

export interface ProxyCreateInput {
  lastUsedAt?: DateTimeInput;
  proxy: String;
  username?: String;
  password?: String;
  ip: String;
  type?: String;
  stopUseUntil?: DateTimeInput;
  lastUsedBy?: String;
  taken?: Boolean;
  blackListed?: Boolean;
  blockCount?: Int;
}

export interface ProxyUpdateInput {
  lastUsedAt?: DateTimeInput;
  proxy?: String;
  username?: String;
  password?: String;
  ip?: String;
  type?: String;
  stopUseUntil?: DateTimeInput;
  lastUsedBy?: String;
  taken?: Boolean;
  blackListed?: Boolean;
  blockCount?: Int;
}

export interface ProxyUpdateManyMutationInput {
  lastUsedAt?: DateTimeInput;
  proxy?: String;
  username?: String;
  password?: String;
  ip?: String;
  type?: String;
  stopUseUntil?: DateTimeInput;
  lastUsedBy?: String;
  taken?: Boolean;
  blackListed?: Boolean;
  blockCount?: Int;
}

export interface StudentCreateInput {
  bookings?: BookingCreateManyWithoutStudentInput;
  zenId?: Int;
  name: String;
  phone?: String;
  email?: String;
}

export interface BookingCreateManyWithoutStudentInput {
  create?:
    | BookingCreateWithoutStudentInput[]
    | BookingCreateWithoutStudentInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface BookingCreateWithoutStudentInput {
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeInput;
  debt?: DebtCreateOneWithoutBookingInput;
  agent: AgentCreateOneWithoutBookingInput;
  amount: Float;
  instructor?: InstructorCreateManyWithoutBookingsInput;
}

export interface StudentUpdateInput {
  bookings?: BookingUpdateManyWithoutStudentInput;
  zenId?: Int;
  name?: String;
  phone?: String;
  email?: String;
}

export interface BookingUpdateManyWithoutStudentInput {
  create?:
    | BookingCreateWithoutStudentInput[]
    | BookingCreateWithoutStudentInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutStudentInput[]
    | BookingUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutStudentInput[]
    | BookingUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface BookingUpdateWithWhereUniqueWithoutStudentInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutStudentDataInput;
}

export interface BookingUpdateWithoutStudentDataInput {
  zenId?: Int;
  name?: String;
  bookedAt?: DateTimeInput;
  debt?: DebtUpdateOneWithoutBookingInput;
  agent?: AgentUpdateOneRequiredWithoutBookingInput;
  amount?: Float;
  instructor?: InstructorUpdateManyWithoutBookingsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutStudentInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutStudentDataInput;
  create: BookingCreateWithoutStudentInput;
}

export interface StudentUpdateManyMutationInput {
  zenId?: Int;
  name?: String;
  phone?: String;
  email?: String;
}

export interface TestCentreCreateInput {
  centreId: Int;
  name?: String;
  postcode: String;
  city?: String;
}

export interface TestCentreUpdateInput {
  centreId?: Int;
  name?: String;
  postcode?: String;
  city?: String;
}

export interface TestCentreUpdateManyMutationInput {
  centreId?: Int;
  name?: String;
  postcode?: String;
  city?: String;
}

export interface UnavailabilityWindowCreateInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reason?: String;
}

export interface UnavailabilityWindowUpdateManyMutationInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  reason?: String;
}

export interface AgentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AgentWhereInput;
  AND?: AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput;
  OR?: AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput;
  NOT?: AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface DebtSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DebtWhereInput;
  AND?: DebtSubscriptionWhereInput[] | DebtSubscriptionWhereInput;
  OR?: DebtSubscriptionWhereInput[] | DebtSubscriptionWhereInput;
  NOT?: DebtSubscriptionWhereInput[] | DebtSubscriptionWhereInput;
}

export interface DebtChaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DebtChaseWhereInput;
  AND?: DebtChaseSubscriptionWhereInput[] | DebtChaseSubscriptionWhereInput;
  OR?: DebtChaseSubscriptionWhereInput[] | DebtChaseSubscriptionWhereInput;
  NOT?: DebtChaseSubscriptionWhereInput[] | DebtChaseSubscriptionWhereInput;
}

export interface FastTrackTestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FastTrackTestWhereInput;
  AND?:
    | FastTrackTestSubscriptionWhereInput[]
    | FastTrackTestSubscriptionWhereInput;
  OR?:
    | FastTrackTestSubscriptionWhereInput[]
    | FastTrackTestSubscriptionWhereInput;
  NOT?:
    | FastTrackTestSubscriptionWhereInput[]
    | FastTrackTestSubscriptionWhereInput;
}

export interface InstructorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InstructorWhereInput;
  AND?: InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput;
  OR?: InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput;
  NOT?: InstructorSubscriptionWhereInput[] | InstructorSubscriptionWhereInput;
}

export interface LatestHistoryIdSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LatestHistoryIdWhereInput;
  AND?:
    | LatestHistoryIdSubscriptionWhereInput[]
    | LatestHistoryIdSubscriptionWhereInput;
  OR?:
    | LatestHistoryIdSubscriptionWhereInput[]
    | LatestHistoryIdSubscriptionWhereInput;
  NOT?:
    | LatestHistoryIdSubscriptionWhereInput[]
    | LatestHistoryIdSubscriptionWhereInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface PracticalTestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PracticalTestWhereInput;
  AND?:
    | PracticalTestSubscriptionWhereInput[]
    | PracticalTestSubscriptionWhereInput;
  OR?:
    | PracticalTestSubscriptionWhereInput[]
    | PracticalTestSubscriptionWhereInput;
  NOT?:
    | PracticalTestSubscriptionWhereInput[]
    | PracticalTestSubscriptionWhereInput;
}

export interface ProxySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProxyWhereInput;
  AND?: ProxySubscriptionWhereInput[] | ProxySubscriptionWhereInput;
  OR?: ProxySubscriptionWhereInput[] | ProxySubscriptionWhereInput;
  NOT?: ProxySubscriptionWhereInput[] | ProxySubscriptionWhereInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface TestCentreSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TestCentreWhereInput;
  AND?: TestCentreSubscriptionWhereInput[] | TestCentreSubscriptionWhereInput;
  OR?: TestCentreSubscriptionWhereInput[] | TestCentreSubscriptionWhereInput;
  NOT?: TestCentreSubscriptionWhereInput[] | TestCentreSubscriptionWhereInput;
}

export interface UnavailabilityWindowSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UnavailabilityWindowWhereInput;
  AND?:
    | UnavailabilityWindowSubscriptionWhereInput[]
    | UnavailabilityWindowSubscriptionWhereInput;
  OR?:
    | UnavailabilityWindowSubscriptionWhereInput[]
    | UnavailabilityWindowSubscriptionWhereInput;
  NOT?:
    | UnavailabilityWindowSubscriptionWhereInput[]
    | UnavailabilityWindowSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Agent {
  id: ID_Output;
  zenId?: Int;
  name: String;
  email?: String;
}

export interface AgentPromise extends Promise<Agent>, Fragmentable {
  id: () => Promise<ID_Output>;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  booking: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AgentSubscription
  extends Promise<AsyncIterator<Agent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  booking: <T = Promise<AsyncIterator<BookingSubscription>>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Booking {
  id: ID_Output;
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeOutput;
  amount: Float;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  bookedAt: () => Promise<DateTimeOutput>;
  debt: <T = DebtPromise>() => T;
  agent: <T = AgentPromise>() => T;
  student: <T = StudentPromise>() => T;
  amount: () => Promise<Float>;
  instructor: <T = FragmentableArray<Instructor>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  bookedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  debt: <T = DebtSubscription>() => T;
  agent: <T = AgentSubscription>() => T;
  student: <T = StudentSubscription>() => T;
  amount: () => Promise<AsyncIterator<Float>>;
  instructor: <T = Promise<AsyncIterator<InstructorSubscription>>>(args?: {
    where?: InstructorWhereInput;
    orderBy?: InstructorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Debt {
  id: ID_Output;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeOutput;
  notes?: String;
}

export interface DebtPromise extends Promise<Debt>, Fragmentable {
  id: () => Promise<ID_Output>;
  booking: <T = BookingPromise>() => T;
  agent: <T = AgentPromise>() => T;
  instructor: <T = InstructorPromise>() => T;
  initialAmount: () => Promise<Float>;
  currentAmount: () => Promise<Float>;
  paidOff: () => Promise<Boolean>;
  status: () => Promise<DebtStatus>;
  dueSince: () => Promise<DateTimeOutput>;
  notes: () => Promise<String>;
  chases: <T = FragmentableArray<DebtChase>>(args?: {
    where?: DebtChaseWhereInput;
    orderBy?: DebtChaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DebtSubscription
  extends Promise<AsyncIterator<Debt>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  booking: <T = BookingSubscription>() => T;
  agent: <T = AgentSubscription>() => T;
  instructor: <T = InstructorSubscription>() => T;
  initialAmount: () => Promise<AsyncIterator<Float>>;
  currentAmount: () => Promise<AsyncIterator<Float>>;
  paidOff: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<DebtStatus>>;
  dueSince: () => Promise<AsyncIterator<DateTimeOutput>>;
  notes: () => Promise<AsyncIterator<String>>;
  chases: <T = Promise<AsyncIterator<DebtChaseSubscription>>>(args?: {
    where?: DebtChaseWhereInput;
    orderBy?: DebtChaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Instructor {
  id: ID_Output;
  zenId?: Int;
  name: String;
  joinedOn?: DateTimeOutput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface InstructorPromise extends Promise<Instructor>, Fragmentable {
  id: () => Promise<ID_Output>;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zenId: () => Promise<Int>;
  debt: <T = FragmentableArray<Debt>>(args?: {
    where?: DebtWhereInput;
    orderBy?: DebtOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  joinedOn: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  city: () => Promise<String>;
  address: () => Promise<String>;
  postcode: () => Promise<String>;
}

export interface InstructorSubscription
  extends Promise<AsyncIterator<Instructor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zenId: () => Promise<AsyncIterator<Int>>;
  debt: <T = Promise<AsyncIterator<DebtSubscription>>>(args?: {
    where?: DebtWhereInput;
    orderBy?: DebtOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  joinedOn: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
}

export interface DebtChase {
  id: ID_Output;
  notes?: String;
  chasedOn: DateTimeOutput;
}

export interface DebtChasePromise extends Promise<DebtChase>, Fragmentable {
  id: () => Promise<ID_Output>;
  debt: <T = DebtPromise>() => T;
  notes: () => Promise<String>;
  chasedOn: () => Promise<DateTimeOutput>;
  chasedBy: <T = AgentPromise>() => T;
}

export interface DebtChaseSubscription
  extends Promise<AsyncIterator<DebtChase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  debt: <T = DebtSubscription>() => T;
  notes: () => Promise<AsyncIterator<String>>;
  chasedOn: () => Promise<AsyncIterator<DateTimeOutput>>;
  chasedBy: <T = AgentSubscription>() => T;
}

export interface Payment {
  id: ID_Output;
  paidOn?: DateTimeOutput;
  amount: Float;
  notes?: String;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  paidOn: () => Promise<DateTimeOutput>;
  debt: <T = DebtPromise>() => T;
  amount: () => Promise<Float>;
  notes: () => Promise<String>;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  paidOn: () => Promise<AsyncIterator<DateTimeOutput>>;
  debt: <T = DebtSubscription>() => T;
  amount: () => Promise<AsyncIterator<Float>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface Student {
  id: ID_Output;
  zenId?: Int;
  name: String;
  phone?: String;
  email?: String;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AgentConnection {
  pageInfo: PageInfo;
  edges: AgentEdge[];
}

export interface AgentConnectionPromise
  extends Promise<AgentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgentEdge>>() => T;
  aggregate: <T = AggregateAgentPromise>() => T;
}

export interface AgentConnectionSubscription
  extends Promise<AsyncIterator<AgentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AgentEdge {
  node: Agent;
  cursor: String;
}

export interface AgentEdgePromise extends Promise<AgentEdge>, Fragmentable {
  node: <T = AgentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgentEdgeSubscription
  extends Promise<AsyncIterator<AgentEdge>>,
    Fragmentable {
  node: <T = AgentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgent {
  count: Int;
}

export interface AggregateAgentPromise
  extends Promise<AggregateAgent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgentSubscription
  extends Promise<AsyncIterator<AggregateAgent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DebtConnection {
  pageInfo: PageInfo;
  edges: DebtEdge[];
}

export interface DebtConnectionPromise
  extends Promise<DebtConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DebtEdge>>() => T;
  aggregate: <T = AggregateDebtPromise>() => T;
}

export interface DebtConnectionSubscription
  extends Promise<AsyncIterator<DebtConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DebtEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDebtSubscription>() => T;
}

export interface DebtEdge {
  node: Debt;
  cursor: String;
}

export interface DebtEdgePromise extends Promise<DebtEdge>, Fragmentable {
  node: <T = DebtPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DebtEdgeSubscription
  extends Promise<AsyncIterator<DebtEdge>>,
    Fragmentable {
  node: <T = DebtSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDebt {
  count: Int;
}

export interface AggregateDebtPromise
  extends Promise<AggregateDebt>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDebtSubscription
  extends Promise<AsyncIterator<AggregateDebt>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DebtChaseConnection {
  pageInfo: PageInfo;
  edges: DebtChaseEdge[];
}

export interface DebtChaseConnectionPromise
  extends Promise<DebtChaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DebtChaseEdge>>() => T;
  aggregate: <T = AggregateDebtChasePromise>() => T;
}

export interface DebtChaseConnectionSubscription
  extends Promise<AsyncIterator<DebtChaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DebtChaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDebtChaseSubscription>() => T;
}

export interface DebtChaseEdge {
  node: DebtChase;
  cursor: String;
}

export interface DebtChaseEdgePromise
  extends Promise<DebtChaseEdge>,
    Fragmentable {
  node: <T = DebtChasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DebtChaseEdgeSubscription
  extends Promise<AsyncIterator<DebtChaseEdge>>,
    Fragmentable {
  node: <T = DebtChaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDebtChase {
  count: Int;
}

export interface AggregateDebtChasePromise
  extends Promise<AggregateDebtChase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDebtChaseSubscription
  extends Promise<AsyncIterator<AggregateDebtChase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FastTrackTest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  studentName?: String;
  area?: String;
  dealOwner?: String;
  instructor?: String;
  testCentrePrimary?: String;
  testCentreSecondary?: String;
  drivinglicense: String;
  applicationRef: String;
  studentPostcode?: String;
  searchPostcode?: String;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  hoursToAvoid: Int[];
  daysToAvoid: Int[];
  datesToAvoid: Int[];
  testCentres: Int[];
  specificDays: Int[];
  specificDates: Int[];
  specificHours: Int[];
  booked?: Boolean;
  bookedDate?: DateTimeOutput;
  bookedCentre?: Int;
  timeWhenBooked?: DateTimeOutput;
  minimumDelay?: Int;
  postcode?: String;
  stopLooking?: Boolean;
}

export interface FastTrackTestPromise
  extends Promise<FastTrackTest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  studentName: () => Promise<String>;
  area: () => Promise<String>;
  dealOwner: () => Promise<String>;
  instructor: () => Promise<String>;
  testCentrePrimary: () => Promise<String>;
  testCentreSecondary: () => Promise<String>;
  drivinglicense: () => Promise<String>;
  applicationRef: () => Promise<String>;
  studentPostcode: () => Promise<String>;
  searchPostcode: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  hoursToAvoid: () => Promise<Int[]>;
  daysToAvoid: () => Promise<Int[]>;
  datesToAvoid: () => Promise<Int[]>;
  testCentres: () => Promise<Int[]>;
  specificDays: () => Promise<Int[]>;
  specificDates: () => Promise<Int[]>;
  specificHours: () => Promise<Int[]>;
  booked: () => Promise<Boolean>;
  bookedDate: () => Promise<DateTimeOutput>;
  bookedCentre: () => Promise<Int>;
  timeWhenBooked: () => Promise<DateTimeOutput>;
  minimumDelay: () => Promise<Int>;
  postcode: () => Promise<String>;
  stopLooking: () => Promise<Boolean>;
}

export interface FastTrackTestSubscription
  extends Promise<AsyncIterator<FastTrackTest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  studentName: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  dealOwner: () => Promise<AsyncIterator<String>>;
  instructor: () => Promise<AsyncIterator<String>>;
  testCentrePrimary: () => Promise<AsyncIterator<String>>;
  testCentreSecondary: () => Promise<AsyncIterator<String>>;
  drivinglicense: () => Promise<AsyncIterator<String>>;
  applicationRef: () => Promise<AsyncIterator<String>>;
  studentPostcode: () => Promise<AsyncIterator<String>>;
  searchPostcode: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  hoursToAvoid: () => Promise<AsyncIterator<Int[]>>;
  daysToAvoid: () => Promise<AsyncIterator<Int[]>>;
  datesToAvoid: () => Promise<AsyncIterator<Int[]>>;
  testCentres: () => Promise<AsyncIterator<Int[]>>;
  specificDays: () => Promise<AsyncIterator<Int[]>>;
  specificDates: () => Promise<AsyncIterator<Int[]>>;
  specificHours: () => Promise<AsyncIterator<Int[]>>;
  booked: () => Promise<AsyncIterator<Boolean>>;
  bookedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookedCentre: () => Promise<AsyncIterator<Int>>;
  timeWhenBooked: () => Promise<AsyncIterator<DateTimeOutput>>;
  minimumDelay: () => Promise<AsyncIterator<Int>>;
  postcode: () => Promise<AsyncIterator<String>>;
  stopLooking: () => Promise<AsyncIterator<Boolean>>;
}

export interface FastTrackTestConnection {
  pageInfo: PageInfo;
  edges: FastTrackTestEdge[];
}

export interface FastTrackTestConnectionPromise
  extends Promise<FastTrackTestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FastTrackTestEdge>>() => T;
  aggregate: <T = AggregateFastTrackTestPromise>() => T;
}

export interface FastTrackTestConnectionSubscription
  extends Promise<AsyncIterator<FastTrackTestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FastTrackTestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFastTrackTestSubscription>() => T;
}

export interface FastTrackTestEdge {
  node: FastTrackTest;
  cursor: String;
}

export interface FastTrackTestEdgePromise
  extends Promise<FastTrackTestEdge>,
    Fragmentable {
  node: <T = FastTrackTestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FastTrackTestEdgeSubscription
  extends Promise<AsyncIterator<FastTrackTestEdge>>,
    Fragmentable {
  node: <T = FastTrackTestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFastTrackTest {
  count: Int;
}

export interface AggregateFastTrackTestPromise
  extends Promise<AggregateFastTrackTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFastTrackTestSubscription
  extends Promise<AsyncIterator<AggregateFastTrackTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InstructorConnection {
  pageInfo: PageInfo;
  edges: InstructorEdge[];
}

export interface InstructorConnectionPromise
  extends Promise<InstructorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InstructorEdge>>() => T;
  aggregate: <T = AggregateInstructorPromise>() => T;
}

export interface InstructorConnectionSubscription
  extends Promise<AsyncIterator<InstructorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InstructorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInstructorSubscription>() => T;
}

export interface InstructorEdge {
  node: Instructor;
  cursor: String;
}

export interface InstructorEdgePromise
  extends Promise<InstructorEdge>,
    Fragmentable {
  node: <T = InstructorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InstructorEdgeSubscription
  extends Promise<AsyncIterator<InstructorEdge>>,
    Fragmentable {
  node: <T = InstructorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInstructor {
  count: Int;
}

export interface AggregateInstructorPromise
  extends Promise<AggregateInstructor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInstructorSubscription
  extends Promise<AsyncIterator<AggregateInstructor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LatestHistoryId {
  id: ID_Output;
  latestId?: String;
  reference?: String;
}

export interface LatestHistoryIdPromise
  extends Promise<LatestHistoryId>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  latestId: () => Promise<String>;
  reference: () => Promise<String>;
}

export interface LatestHistoryIdSubscription
  extends Promise<AsyncIterator<LatestHistoryId>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latestId: () => Promise<AsyncIterator<String>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface LatestHistoryIdConnection {
  pageInfo: PageInfo;
  edges: LatestHistoryIdEdge[];
}

export interface LatestHistoryIdConnectionPromise
  extends Promise<LatestHistoryIdConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LatestHistoryIdEdge>>() => T;
  aggregate: <T = AggregateLatestHistoryIdPromise>() => T;
}

export interface LatestHistoryIdConnectionSubscription
  extends Promise<AsyncIterator<LatestHistoryIdConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LatestHistoryIdEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLatestHistoryIdSubscription>() => T;
}

export interface LatestHistoryIdEdge {
  node: LatestHistoryId;
  cursor: String;
}

export interface LatestHistoryIdEdgePromise
  extends Promise<LatestHistoryIdEdge>,
    Fragmentable {
  node: <T = LatestHistoryIdPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LatestHistoryIdEdgeSubscription
  extends Promise<AsyncIterator<LatestHistoryIdEdge>>,
    Fragmentable {
  node: <T = LatestHistoryIdSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLatestHistoryId {
  count: Int;
}

export interface AggregateLatestHistoryIdPromise
  extends Promise<AggregateLatestHistoryId>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLatestHistoryIdSubscription
  extends Promise<AsyncIterator<AggregateLatestHistoryId>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PracticalTest {
  id: ID_Output;
  gmailId?: String;
  checkTelephone?: String;
  studentName?: String;
  location?: String;
  testDate?: DateTimeOutput;
  lastChangeDate?: DateTimeOutput;
  reference: String;
  emailContent?: String;
  isConfirmed: Boolean;
  status: PracticalTestStatus;
}

export interface PracticalTestPromise
  extends Promise<PracticalTest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  gmailId: () => Promise<String>;
  checkTelephone: () => Promise<String>;
  studentName: () => Promise<String>;
  location: () => Promise<String>;
  testDate: () => Promise<DateTimeOutput>;
  lastChangeDate: () => Promise<DateTimeOutput>;
  reference: () => Promise<String>;
  booking: <T = BookingPromise>() => T;
  emailContent: () => Promise<String>;
  isConfirmed: () => Promise<Boolean>;
  status: () => Promise<PracticalTestStatus>;
}

export interface PracticalTestSubscription
  extends Promise<AsyncIterator<PracticalTest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gmailId: () => Promise<AsyncIterator<String>>;
  checkTelephone: () => Promise<AsyncIterator<String>>;
  studentName: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  testDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastChangeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  reference: () => Promise<AsyncIterator<String>>;
  booking: <T = BookingSubscription>() => T;
  emailContent: () => Promise<AsyncIterator<String>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<PracticalTestStatus>>;
}

export interface PracticalTestConnection {
  pageInfo: PageInfo;
  edges: PracticalTestEdge[];
}

export interface PracticalTestConnectionPromise
  extends Promise<PracticalTestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PracticalTestEdge>>() => T;
  aggregate: <T = AggregatePracticalTestPromise>() => T;
}

export interface PracticalTestConnectionSubscription
  extends Promise<AsyncIterator<PracticalTestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PracticalTestEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePracticalTestSubscription>() => T;
}

export interface PracticalTestEdge {
  node: PracticalTest;
  cursor: String;
}

export interface PracticalTestEdgePromise
  extends Promise<PracticalTestEdge>,
    Fragmentable {
  node: <T = PracticalTestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PracticalTestEdgeSubscription
  extends Promise<AsyncIterator<PracticalTestEdge>>,
    Fragmentable {
  node: <T = PracticalTestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePracticalTest {
  count: Int;
}

export interface AggregatePracticalTestPromise
  extends Promise<AggregatePracticalTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePracticalTestSubscription
  extends Promise<AsyncIterator<AggregatePracticalTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Proxy {
  lastUsedAt?: DateTimeOutput;
  proxy: String;
  username?: String;
  password?: String;
  ip: String;
  type?: String;
  stopUseUntil?: DateTimeOutput;
  lastUsedBy?: String;
  taken?: Boolean;
  blackListed?: Boolean;
  blockCount?: Int;
}

export interface ProxyPromise extends Promise<Proxy>, Fragmentable {
  lastUsedAt: () => Promise<DateTimeOutput>;
  proxy: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  ip: () => Promise<String>;
  type: () => Promise<String>;
  stopUseUntil: () => Promise<DateTimeOutput>;
  lastUsedBy: () => Promise<String>;
  taken: () => Promise<Boolean>;
  blackListed: () => Promise<Boolean>;
  blockCount: () => Promise<Int>;
}

export interface ProxySubscription
  extends Promise<AsyncIterator<Proxy>>,
    Fragmentable {
  lastUsedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  proxy: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  ip: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  stopUseUntil: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastUsedBy: () => Promise<AsyncIterator<String>>;
  taken: () => Promise<AsyncIterator<Boolean>>;
  blackListed: () => Promise<AsyncIterator<Boolean>>;
  blockCount: () => Promise<AsyncIterator<Int>>;
}

export interface ProxyConnection {
  pageInfo: PageInfo;
  edges: ProxyEdge[];
}

export interface ProxyConnectionPromise
  extends Promise<ProxyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProxyEdge>>() => T;
  aggregate: <T = AggregateProxyPromise>() => T;
}

export interface ProxyConnectionSubscription
  extends Promise<AsyncIterator<ProxyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProxyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProxySubscription>() => T;
}

export interface ProxyEdge {
  node: Proxy;
  cursor: String;
}

export interface ProxyEdgePromise extends Promise<ProxyEdge>, Fragmentable {
  node: <T = ProxyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProxyEdgeSubscription
  extends Promise<AsyncIterator<ProxyEdge>>,
    Fragmentable {
  node: <T = ProxySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProxy {
  count: Int;
}

export interface AggregateProxyPromise
  extends Promise<AggregateProxy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProxySubscription
  extends Promise<AsyncIterator<AggregateProxy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestCentre {
  centreId: Int;
  name?: String;
  postcode: String;
  city?: String;
}

export interface TestCentrePromise extends Promise<TestCentre>, Fragmentable {
  centreId: () => Promise<Int>;
  name: () => Promise<String>;
  postcode: () => Promise<String>;
  city: () => Promise<String>;
}

export interface TestCentreSubscription
  extends Promise<AsyncIterator<TestCentre>>,
    Fragmentable {
  centreId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
}

export interface TestCentreConnection {
  pageInfo: PageInfo;
  edges: TestCentreEdge[];
}

export interface TestCentreConnectionPromise
  extends Promise<TestCentreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestCentreEdge>>() => T;
  aggregate: <T = AggregateTestCentrePromise>() => T;
}

export interface TestCentreConnectionSubscription
  extends Promise<AsyncIterator<TestCentreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestCentreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestCentreSubscription>() => T;
}

export interface TestCentreEdge {
  node: TestCentre;
  cursor: String;
}

export interface TestCentreEdgePromise
  extends Promise<TestCentreEdge>,
    Fragmentable {
  node: <T = TestCentrePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestCentreEdgeSubscription
  extends Promise<AsyncIterator<TestCentreEdge>>,
    Fragmentable {
  node: <T = TestCentreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTestCentre {
  count: Int;
}

export interface AggregateTestCentrePromise
  extends Promise<AggregateTestCentre>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestCentreSubscription
  extends Promise<AsyncIterator<AggregateTestCentre>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UnavailabilityWindow {
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  reason?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UnavailabilityWindowPromise
  extends Promise<UnavailabilityWindow>,
    Fragmentable {
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reason: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UnavailabilityWindowSubscription
  extends Promise<AsyncIterator<UnavailabilityWindow>>,
    Fragmentable {
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reason: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UnavailabilityWindowConnection {
  pageInfo: PageInfo;
  edges: UnavailabilityWindowEdge[];
}

export interface UnavailabilityWindowConnectionPromise
  extends Promise<UnavailabilityWindowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UnavailabilityWindowEdge>>() => T;
  aggregate: <T = AggregateUnavailabilityWindowPromise>() => T;
}

export interface UnavailabilityWindowConnectionSubscription
  extends Promise<AsyncIterator<UnavailabilityWindowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UnavailabilityWindowEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUnavailabilityWindowSubscription>() => T;
}

export interface UnavailabilityWindowEdge {
  node: UnavailabilityWindow;
  cursor: String;
}

export interface UnavailabilityWindowEdgePromise
  extends Promise<UnavailabilityWindowEdge>,
    Fragmentable {
  node: <T = UnavailabilityWindowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UnavailabilityWindowEdgeSubscription
  extends Promise<AsyncIterator<UnavailabilityWindowEdge>>,
    Fragmentable {
  node: <T = UnavailabilityWindowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUnavailabilityWindow {
  count: Int;
}

export interface AggregateUnavailabilityWindowPromise
  extends Promise<AggregateUnavailabilityWindow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUnavailabilityWindowSubscription
  extends Promise<AsyncIterator<AggregateUnavailabilityWindow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AgentSubscriptionPayload {
  mutation: MutationType;
  node: Agent;
  updatedFields: String[];
  previousValues: AgentPreviousValues;
}

export interface AgentSubscriptionPayloadPromise
  extends Promise<AgentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgentPreviousValuesPromise>() => T;
}

export interface AgentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgentPreviousValuesSubscription>() => T;
}

export interface AgentPreviousValues {
  id: ID_Output;
  zenId?: Int;
  name: String;
  email?: String;
}

export interface AgentPreviousValuesPromise
  extends Promise<AgentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  email: () => Promise<String>;
}

export interface AgentPreviousValuesSubscription
  extends Promise<AsyncIterator<AgentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface BookingPreviousValues {
  id: ID_Output;
  zenId?: Int;
  name: String;
  bookedAt?: DateTimeOutput;
  amount: Float;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  bookedAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Float>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  bookedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Float>>;
}

export interface DebtSubscriptionPayload {
  mutation: MutationType;
  node: Debt;
  updatedFields: String[];
  previousValues: DebtPreviousValues;
}

export interface DebtSubscriptionPayloadPromise
  extends Promise<DebtSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DebtPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DebtPreviousValuesPromise>() => T;
}

export interface DebtSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DebtSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DebtSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DebtPreviousValuesSubscription>() => T;
}

export interface DebtPreviousValues {
  id: ID_Output;
  initialAmount: Float;
  currentAmount: Float;
  paidOff?: Boolean;
  status?: DebtStatus;
  dueSince?: DateTimeOutput;
  notes?: String;
}

export interface DebtPreviousValuesPromise
  extends Promise<DebtPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  initialAmount: () => Promise<Float>;
  currentAmount: () => Promise<Float>;
  paidOff: () => Promise<Boolean>;
  status: () => Promise<DebtStatus>;
  dueSince: () => Promise<DateTimeOutput>;
  notes: () => Promise<String>;
}

export interface DebtPreviousValuesSubscription
  extends Promise<AsyncIterator<DebtPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  initialAmount: () => Promise<AsyncIterator<Float>>;
  currentAmount: () => Promise<AsyncIterator<Float>>;
  paidOff: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<DebtStatus>>;
  dueSince: () => Promise<AsyncIterator<DateTimeOutput>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface DebtChaseSubscriptionPayload {
  mutation: MutationType;
  node: DebtChase;
  updatedFields: String[];
  previousValues: DebtChasePreviousValues;
}

export interface DebtChaseSubscriptionPayloadPromise
  extends Promise<DebtChaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DebtChasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DebtChasePreviousValuesPromise>() => T;
}

export interface DebtChaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DebtChaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DebtChaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DebtChasePreviousValuesSubscription>() => T;
}

export interface DebtChasePreviousValues {
  id: ID_Output;
  notes?: String;
  chasedOn: DateTimeOutput;
}

export interface DebtChasePreviousValuesPromise
  extends Promise<DebtChasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  notes: () => Promise<String>;
  chasedOn: () => Promise<DateTimeOutput>;
}

export interface DebtChasePreviousValuesSubscription
  extends Promise<AsyncIterator<DebtChasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  notes: () => Promise<AsyncIterator<String>>;
  chasedOn: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FastTrackTestSubscriptionPayload {
  mutation: MutationType;
  node: FastTrackTest;
  updatedFields: String[];
  previousValues: FastTrackTestPreviousValues;
}

export interface FastTrackTestSubscriptionPayloadPromise
  extends Promise<FastTrackTestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FastTrackTestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FastTrackTestPreviousValuesPromise>() => T;
}

export interface FastTrackTestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FastTrackTestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FastTrackTestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FastTrackTestPreviousValuesSubscription>() => T;
}

export interface FastTrackTestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  studentName?: String;
  area?: String;
  dealOwner?: String;
  instructor?: String;
  testCentrePrimary?: String;
  testCentreSecondary?: String;
  drivinglicense: String;
  applicationRef: String;
  studentPostcode?: String;
  searchPostcode?: String;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  hoursToAvoid: Int[];
  daysToAvoid: Int[];
  datesToAvoid: Int[];
  testCentres: Int[];
  specificDays: Int[];
  specificDates: Int[];
  specificHours: Int[];
  booked?: Boolean;
  bookedDate?: DateTimeOutput;
  bookedCentre?: Int;
  timeWhenBooked?: DateTimeOutput;
  minimumDelay?: Int;
  postcode?: String;
  stopLooking?: Boolean;
}

export interface FastTrackTestPreviousValuesPromise
  extends Promise<FastTrackTestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  studentName: () => Promise<String>;
  area: () => Promise<String>;
  dealOwner: () => Promise<String>;
  instructor: () => Promise<String>;
  testCentrePrimary: () => Promise<String>;
  testCentreSecondary: () => Promise<String>;
  drivinglicense: () => Promise<String>;
  applicationRef: () => Promise<String>;
  studentPostcode: () => Promise<String>;
  searchPostcode: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  hoursToAvoid: () => Promise<Int[]>;
  daysToAvoid: () => Promise<Int[]>;
  datesToAvoid: () => Promise<Int[]>;
  testCentres: () => Promise<Int[]>;
  specificDays: () => Promise<Int[]>;
  specificDates: () => Promise<Int[]>;
  specificHours: () => Promise<Int[]>;
  booked: () => Promise<Boolean>;
  bookedDate: () => Promise<DateTimeOutput>;
  bookedCentre: () => Promise<Int>;
  timeWhenBooked: () => Promise<DateTimeOutput>;
  minimumDelay: () => Promise<Int>;
  postcode: () => Promise<String>;
  stopLooking: () => Promise<Boolean>;
}

export interface FastTrackTestPreviousValuesSubscription
  extends Promise<AsyncIterator<FastTrackTestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  studentName: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  dealOwner: () => Promise<AsyncIterator<String>>;
  instructor: () => Promise<AsyncIterator<String>>;
  testCentrePrimary: () => Promise<AsyncIterator<String>>;
  testCentreSecondary: () => Promise<AsyncIterator<String>>;
  drivinglicense: () => Promise<AsyncIterator<String>>;
  applicationRef: () => Promise<AsyncIterator<String>>;
  studentPostcode: () => Promise<AsyncIterator<String>>;
  searchPostcode: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  hoursToAvoid: () => Promise<AsyncIterator<Int[]>>;
  daysToAvoid: () => Promise<AsyncIterator<Int[]>>;
  datesToAvoid: () => Promise<AsyncIterator<Int[]>>;
  testCentres: () => Promise<AsyncIterator<Int[]>>;
  specificDays: () => Promise<AsyncIterator<Int[]>>;
  specificDates: () => Promise<AsyncIterator<Int[]>>;
  specificHours: () => Promise<AsyncIterator<Int[]>>;
  booked: () => Promise<AsyncIterator<Boolean>>;
  bookedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookedCentre: () => Promise<AsyncIterator<Int>>;
  timeWhenBooked: () => Promise<AsyncIterator<DateTimeOutput>>;
  minimumDelay: () => Promise<AsyncIterator<Int>>;
  postcode: () => Promise<AsyncIterator<String>>;
  stopLooking: () => Promise<AsyncIterator<Boolean>>;
}

export interface InstructorSubscriptionPayload {
  mutation: MutationType;
  node: Instructor;
  updatedFields: String[];
  previousValues: InstructorPreviousValues;
}

export interface InstructorSubscriptionPayloadPromise
  extends Promise<InstructorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InstructorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InstructorPreviousValuesPromise>() => T;
}

export interface InstructorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InstructorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InstructorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InstructorPreviousValuesSubscription>() => T;
}

export interface InstructorPreviousValues {
  id: ID_Output;
  zenId?: Int;
  name: String;
  joinedOn?: DateTimeOutput;
  phone?: String;
  email?: String;
  city?: String;
  address?: String;
  postcode?: String;
}

export interface InstructorPreviousValuesPromise
  extends Promise<InstructorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  joinedOn: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
  city: () => Promise<String>;
  address: () => Promise<String>;
  postcode: () => Promise<String>;
}

export interface InstructorPreviousValuesSubscription
  extends Promise<AsyncIterator<InstructorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  joinedOn: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
}

export interface LatestHistoryIdSubscriptionPayload {
  mutation: MutationType;
  node: LatestHistoryId;
  updatedFields: String[];
  previousValues: LatestHistoryIdPreviousValues;
}

export interface LatestHistoryIdSubscriptionPayloadPromise
  extends Promise<LatestHistoryIdSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LatestHistoryIdPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LatestHistoryIdPreviousValuesPromise>() => T;
}

export interface LatestHistoryIdSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LatestHistoryIdSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LatestHistoryIdSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LatestHistoryIdPreviousValuesSubscription>() => T;
}

export interface LatestHistoryIdPreviousValues {
  id: ID_Output;
  latestId?: String;
  reference?: String;
}

export interface LatestHistoryIdPreviousValuesPromise
  extends Promise<LatestHistoryIdPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  latestId: () => Promise<String>;
  reference: () => Promise<String>;
}

export interface LatestHistoryIdPreviousValuesSubscription
  extends Promise<AsyncIterator<LatestHistoryIdPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latestId: () => Promise<AsyncIterator<String>>;
  reference: () => Promise<AsyncIterator<String>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  paidOn?: DateTimeOutput;
  amount: Float;
  notes?: String;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  paidOn: () => Promise<DateTimeOutput>;
  amount: () => Promise<Float>;
  notes: () => Promise<String>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  paidOn: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Float>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface PracticalTestSubscriptionPayload {
  mutation: MutationType;
  node: PracticalTest;
  updatedFields: String[];
  previousValues: PracticalTestPreviousValues;
}

export interface PracticalTestSubscriptionPayloadPromise
  extends Promise<PracticalTestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PracticalTestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PracticalTestPreviousValuesPromise>() => T;
}

export interface PracticalTestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PracticalTestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PracticalTestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PracticalTestPreviousValuesSubscription>() => T;
}

export interface PracticalTestPreviousValues {
  id: ID_Output;
  gmailId?: String;
  checkTelephone?: String;
  studentName?: String;
  location?: String;
  testDate?: DateTimeOutput;
  lastChangeDate?: DateTimeOutput;
  reference: String;
  emailContent?: String;
  isConfirmed: Boolean;
  status: PracticalTestStatus;
}

export interface PracticalTestPreviousValuesPromise
  extends Promise<PracticalTestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  gmailId: () => Promise<String>;
  checkTelephone: () => Promise<String>;
  studentName: () => Promise<String>;
  location: () => Promise<String>;
  testDate: () => Promise<DateTimeOutput>;
  lastChangeDate: () => Promise<DateTimeOutput>;
  reference: () => Promise<String>;
  emailContent: () => Promise<String>;
  isConfirmed: () => Promise<Boolean>;
  status: () => Promise<PracticalTestStatus>;
}

export interface PracticalTestPreviousValuesSubscription
  extends Promise<AsyncIterator<PracticalTestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gmailId: () => Promise<AsyncIterator<String>>;
  checkTelephone: () => Promise<AsyncIterator<String>>;
  studentName: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  testDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastChangeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  reference: () => Promise<AsyncIterator<String>>;
  emailContent: () => Promise<AsyncIterator<String>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
  status: () => Promise<AsyncIterator<PracticalTestStatus>>;
}

export interface ProxySubscriptionPayload {
  mutation: MutationType;
  node: Proxy;
  updatedFields: String[];
  previousValues: ProxyPreviousValues;
}

export interface ProxySubscriptionPayloadPromise
  extends Promise<ProxySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProxyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProxyPreviousValuesPromise>() => T;
}

export interface ProxySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProxySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProxySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProxyPreviousValuesSubscription>() => T;
}

export interface ProxyPreviousValues {
  lastUsedAt?: DateTimeOutput;
  proxy: String;
  username?: String;
  password?: String;
  ip: String;
  type?: String;
  stopUseUntil?: DateTimeOutput;
  lastUsedBy?: String;
  taken?: Boolean;
  blackListed?: Boolean;
  blockCount?: Int;
}

export interface ProxyPreviousValuesPromise
  extends Promise<ProxyPreviousValues>,
    Fragmentable {
  lastUsedAt: () => Promise<DateTimeOutput>;
  proxy: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  ip: () => Promise<String>;
  type: () => Promise<String>;
  stopUseUntil: () => Promise<DateTimeOutput>;
  lastUsedBy: () => Promise<String>;
  taken: () => Promise<Boolean>;
  blackListed: () => Promise<Boolean>;
  blockCount: () => Promise<Int>;
}

export interface ProxyPreviousValuesSubscription
  extends Promise<AsyncIterator<ProxyPreviousValues>>,
    Fragmentable {
  lastUsedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  proxy: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  ip: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  stopUseUntil: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastUsedBy: () => Promise<AsyncIterator<String>>;
  taken: () => Promise<AsyncIterator<Boolean>>;
  blackListed: () => Promise<AsyncIterator<Boolean>>;
  blockCount: () => Promise<AsyncIterator<Int>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  zenId?: Int;
  name: String;
  phone?: String;
  email?: String;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  zenId: () => Promise<Int>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  zenId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface TestCentreSubscriptionPayload {
  mutation: MutationType;
  node: TestCentre;
  updatedFields: String[];
  previousValues: TestCentrePreviousValues;
}

export interface TestCentreSubscriptionPayloadPromise
  extends Promise<TestCentreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestCentrePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestCentrePreviousValuesPromise>() => T;
}

export interface TestCentreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestCentreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestCentreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestCentrePreviousValuesSubscription>() => T;
}

export interface TestCentrePreviousValues {
  centreId: Int;
  name?: String;
  postcode: String;
  city?: String;
}

export interface TestCentrePreviousValuesPromise
  extends Promise<TestCentrePreviousValues>,
    Fragmentable {
  centreId: () => Promise<Int>;
  name: () => Promise<String>;
  postcode: () => Promise<String>;
  city: () => Promise<String>;
}

export interface TestCentrePreviousValuesSubscription
  extends Promise<AsyncIterator<TestCentrePreviousValues>>,
    Fragmentable {
  centreId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
}

export interface UnavailabilityWindowSubscriptionPayload {
  mutation: MutationType;
  node: UnavailabilityWindow;
  updatedFields: String[];
  previousValues: UnavailabilityWindowPreviousValues;
}

export interface UnavailabilityWindowSubscriptionPayloadPromise
  extends Promise<UnavailabilityWindowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UnavailabilityWindowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UnavailabilityWindowPreviousValuesPromise>() => T;
}

export interface UnavailabilityWindowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UnavailabilityWindowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UnavailabilityWindowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UnavailabilityWindowPreviousValuesSubscription>() => T;
}

export interface UnavailabilityWindowPreviousValues {
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  reason?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UnavailabilityWindowPreviousValuesPromise
  extends Promise<UnavailabilityWindowPreviousValues>,
    Fragmentable {
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reason: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UnavailabilityWindowPreviousValuesSubscription
  extends Promise<AsyncIterator<UnavailabilityWindowPreviousValues>>,
    Fragmentable {
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reason: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Agent",
    embedded: false
  },
  {
    name: "Instructor",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "DebtStatus",
    embedded: false
  },
  {
    name: "Debt",
    embedded: false
  },
  {
    name: "DebtChase",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "PracticalTestStatus",
    embedded: false
  },
  {
    name: "PracticalTest",
    embedded: false
  },
  {
    name: "FastTrackTest",
    embedded: false
  },
  {
    name: "LatestHistoryId",
    embedded: false
  },
  {
    name: "TestCentre",
    embedded: false
  },
  {
    name: "Proxy",
    embedded: false
  },
  {
    name: "UnavailabilityWindow",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://dashboard.passmefast.co.uk:4466`
});
export const prisma = new Prisma();
